<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>你好呀Pio酱</title>
    <url>/orange-cat-win.github.io/2020/08/12/firstblog/</url>
    <content><![CDATA[<h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>终于搭建好自己的博客了，面板娘也确实好萌<br>昨天一直上传到github失败，背景图片点击特效都不见了</p>
<a id="more"></a>
<p><img src="cry.jpg"><br>不过今天早上打开网页发现居然成功啦<br>原来是这个github外网太慢,加载时间长的问题o(╥﹏╥)o<br>博客采用的是基于github+hexo搭建的<br>这种应该是最<strong>简单</strong>的博客搭建方式了<br>写博客的话是用markdown标记语言和typora编辑器相结合的<br>以后会把自己学习当中的心得啊使用编程语言的知识都不断的<br>更新我这个博客，等到自己有实力的时候慢慢的把博客变的美观吧<br>我把看过搭建成功的教程给大家一下链接吧</p>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>1.<a href="https://www.bilibili.com/video/BV1cW411A7Jx#reply3319197381">手把手教你搭建属于自己的hexo+github博客</a><br>  这个视频介绍了大概需要安装的软件,github注册设置和hexo的使用那些必须的内容<br>2.<a href="https://www.bilibili.com/video/BV16W411t7mq?from=search&seid=5303042034556358051">使用Hexo博客搭建的个人博客，使用Next主题来进行优化改造</a><br>  这个视频讲解了使用hexo博客next主题框架的修改，修改一番博客就可以使用啦<br>3.<a href="https://blog.pangao.vip/Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E4%B9%8B%E6%96%B0%E5%A2%9E%E7%9C%8B%E6%9D%BF%E5%A8%98(%E8%83%BD%E8%AF%B4%E8%AF%9D%E3%80%81%E8%83%BD%E6%8D%A2%E8%A3%85)/">Hexo博客NexT主题美化之新增看板娘</a><br>  这个博客讲解教会你如何增加看板娘，操作使用看板娘，墙裂推荐<br>4.<a href="https://bestzuo.cn/posts/446056512.html">给博客添加鼠标点击特效</a><br>  这个博客讲解怎么添加鼠标特效，直接饮用就好啦<br>其他的还有使用网易云音乐，增加背景图片，如何使用hexo博客图片，valine评论系统的魔改等等百度一下就好啦，如果搭建像我这样简单的博客系统，一天时间其实就绰绰有余了，像其他那些大佬搭建复杂的那些很炫酷的博客，那个我就心有余而力不足啦</p>
]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>首篇文章</tag>
        <tag>小小开心</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS三种输出最短路径的方式</title>
    <url>/orange-cat-win.github.io/2020/08/12/BFS%E4%B8%89%E7%A7%8D%E8%BE%93%E5%87%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>相信我，看完之后，你会对BFS有种全新的了解，彻底掌握BFS<br><del>只需要这一篇就足够啦，狗头</del> </p>
<h1 id="BFS路径表示"><a href="#BFS路径表示" class="headerlink" title="BFS路径表示"></a>BFS路径表示</h1><p>广度优先搜索顾名思义就是以迷宫里的无向图某一个点，借助队列，一层一层以该点为中心散开进行搜索，简单的BFS只能显示出最短路径的长度，这里探讨的就是如何实现BFS对最短路径的输出</p>
<a id="more"></a>
<h3 id="简单的BFS"><a href="#简单的BFS" class="headerlink" title="简单的BFS"></a>简单的BFS</h3><p>通过队列来实现，找到迷宫的起点（S）入队，出队列里面的队首，把队首上下左右相邻的点入队列，一直重复此操作，直到队列里面的所有元素都出队表示该迷宫不存在解，如果在队清空之前找到终点(T)的话，一层一层的遍历，找到的话就一定是最短路了，但是简单的BFS只能通过输出(now.d+1)来表示最短路的步数长度，不能表示出最短路径到底是什么？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;<span class="comment">//地图长宽</span></span><br><span class="line"><span class="built_in">string</span> maze[<span class="number">110</span>];<span class="comment">//地图</span></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">110</span>][<span class="number">110</span>];<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;<span class="comment">//方向变化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">//确保在地图里面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= x &amp;&amp; x &lt; n &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="comment">//定义node类型的结构体</span></span><br><span class="line">    <span class="keyword">int</span> x,y,d;<span class="comment">//d表示路径</span></span><br><span class="line">    node(<span class="keyword">int</span> xx,<span class="keyword">int</span> yy,<span class="keyword">int</span> dd)&#123;<span class="comment">//便于输入结构体里面的值</span></span><br><span class="line">        x=xx;</span><br><span class="line">        y=yy;</span><br><span class="line">        d=dd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> sx,<span class="keyword">int</span> sy)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">    q.push(node(sx,sy,<span class="number">0</span>));<span class="comment">//将起点放入</span></span><br><span class="line">    vis[sx][sy]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;<span class="comment">//队列如果不为空继续</span></span><br><span class="line">        node now=q.front();<span class="comment">//找到队首</span></span><br><span class="line">        q.pop();<span class="comment">//队首出队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx=now.x+dir[i][<span class="number">0</span>];<span class="comment">//周围遍历</span></span><br><span class="line">            <span class="keyword">int</span> ty=now.y+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(in(tx,ty)&amp;&amp;maze[tx][ty]!=<span class="string">&#x27;*&#x27;</span>&amp;&amp;!vis[tx][ty])&#123;<span class="comment">//在界内且未遍历到</span></span><br><span class="line">                <span class="keyword">if</span>(maze[tx][ty]==<span class="string">&#x27;T&#x27;</span>)&#123;<span class="comment">//如果是终点，BFS返回完成</span></span><br><span class="line">                    <span class="keyword">return</span> now.d+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果不是不返回，标记该点入队继续搜索</span></span><br><span class="line">                    vis[tx][ty]=<span class="literal">true</span>;</span><br><span class="line">                    q.push(node(tx,ty,now.d+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//队空未找到就返回-1表示无解</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; maze[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maze[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;<span class="comment">//找到迷宫的起点</span></span><br><span class="line">                x = i, y = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;bfs(x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我下午问了杰哥一下，杰哥给我介绍了两种思路下面的三种方法<br>真的杰哥这些思路都是很经典很厉害的思想</p>
<h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>就直接引用原话啦<br><img src="https://img-blog.csdnimg.cn/20200317191844731.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我看着杰哥的代码理解了一下，大概意思就是<br>1.首先正着从起点进行一遍BFS找到终点，再从终点反正来一遍BFS找到起点<br>2.开创俩个数组dis1[N][N]和dis2[N][N]分别用于记录正向搜索每一次的出队时的每一个离起点的层数和反向搜索每一次的出队时的每一个点离起点的层数<br>3.此时通过BFS我们已经知道最短路径的长度了，某个点只要能满足<br>dis1[x][y]+dis2[x][y]=minrode<br>那么这个点就一定是这个迷宫最短路径上面的点<br>4.通过这样我们就能知道该迷宫的最短路径表示<br><img src="https://img-blog.csdnimg.cn/20200317193310520.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码展示如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">include&lt;<span class="built_in">queue</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;<span class="comment">//地图最大宽度 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;que;</span><br><span class="line"><span class="keyword">int</span> n,m,minrode=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fx,fy;<span class="comment">//记录终点的坐标值 </span></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dis1[N][N];<span class="comment">//正向记录层数的数组 </span></span><br><span class="line"><span class="keyword">int</span> dis2[N][N];<span class="comment">//逆向记录层数的数组 </span></span><br><span class="line"><span class="keyword">bool</span> mark[N][N];<span class="comment">//用来标记是不是在最短路上 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> dis[][N],<span class="keyword">int</span> sx,<span class="keyword">int</span> sy)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//初始化记录层数的dis数组 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            dis[i][j]=<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!que.empty())que.pop();<span class="comment">//初始化队列 </span></span><br><span class="line">    </span><br><span class="line">    que.push((node)&#123;sx,sy&#125;);<span class="comment">//放入起点 </span></span><br><span class="line">    dis[sx][sy]=<span class="number">0</span>;<span class="comment">//(sx,sy)为起点 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        node cur=que.front();<span class="comment">//当前状态</span></span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            node nxt;</span><br><span class="line">            nxt.x=cur.x+dx[i];</span><br><span class="line">            nxt.y=cur.y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[nxt.x][nxt.y]==<span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//墙壁无法通行 </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(nxt.x&gt;=<span class="number">0</span>&amp;&amp;nxt.x&lt;n&amp;&amp;nxt.y&gt;=<span class="number">0</span>&amp;&amp;nxt.y&lt;m&amp;&amp;dis[nxt.x][nxt.y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[nxt.x][nxt.y]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">                    fx=nxt.x;fy=nxt.y;</span><br><span class="line">                    minrode=dis[cur.x][cur.y]+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                que.push(nxt); </span><br><span class="line">                dis[nxt.x][nxt.y]=dis[cur.x][cur.y]+<span class="number">1</span>;<span class="comment">//不断的记录层数</span></span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//对起点进行上下左右找，满足的mark=true的进行输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x,y);    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;<span class="comment">//同样的进行遍历判断 </span></span><br><span class="line">        <span class="keyword">int</span> nx=x+dx[i];</span><br><span class="line">        <span class="keyword">int</span> ny=y+dy[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nx&lt;<span class="number">0</span>||nx&gt;=n||ny&lt;<span class="number">0</span>||ny&gt;=m||<span class="built_in">map</span>[nx][ny]==<span class="string">&#x27;#&#x27;</span>)<span class="keyword">continue</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dis1[nx][ny]&lt;dis1[x][y])<span class="keyword">continue</span>;<span class="comment">//***不能往回走不能成环 </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mark[nx][ny])&#123;</span><br><span class="line">            Print(nx,ny);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//避免输出多条最短路 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> qx,qy;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">map</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;<span class="comment">//找到迷宫的起点</span></span><br><span class="line">                qx = i;qy = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BFS(dis1,qx,qy);<span class="comment">//正向遍历 </span></span><br><span class="line">    BFS(dis2,fx,fy);<span class="comment">//逆向遍历 </span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(mark,<span class="number">0</span>,<span class="keyword">sizeof</span>(mark));<span class="comment">//初始化最短路径记录数组 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> total=minrode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis1[i][j]+dis2[i][j]==total)&#123; </span><br><span class="line">                mark[i][j]=<span class="literal">true</span>;<span class="comment">//如果符合的话就是最短路，mark数组该点标记为true </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Print(qx,qy);<span class="comment">//调用print函数进行打印mark上面为true的点 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>重点来了，关键关键关键！！！</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(dis1[nx][ny]&lt;dis1[x][y])<span class="keyword">continue</span>;<span class="comment">//***不能往回走不能成环 </span></span><br></pre></td></tr></table></figure>
<p>这一步真的print函数的重点所在<br>为什么能打印满足mark数组等于true的点，我们要知道一个迷宫不只有一条最短路，有很多点都满足这个这个条件，那么万一出现这种成环的情况怎么办？<br><img src="https://img-blog.csdnimg.cn/20200317200510186.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>按照print函数层次遍历的算法，在A点可以会向右跑了，这样根本不是最短路，但是我们知道按照最短的遍历,dis1数组上面符合最短路的下一步的值一定会比这一步要大，我们在这里就可以做出限制条件，这样一方面就避免了往回回溯的可能，也避免了成环跑掉的可能，如果最短路不成环的话,我们也可以对已经打印出来的点进行标记，标记后不能打印，这样也可以实现避免了往回回溯的可能。</p>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p><del>照片如图</del><br><img src="https://img-blog.csdnimg.cn/2020031720113558.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这种思路大概就很像树型结构的寻找父亲，保存此时的坐标的信息和上一个坐标的信息，从终点往回不断的找，找父亲的父亲的父亲….直到起点为止，这样找下来也是一种最短路，像我这样就只能想到一些<strong>笨办法</strong><br><strong>第一种</strong>就是直接建立树，这个树结点不仅保存该点的值，还保存下面儿子的地址和上面父亲结点的地址，这样一来直接就可以通过树来找到了，要写树代码量真的太大了，舍去。。。<br><strong>第二种</strong>就是建立结构体包含四个值，自己的XY坐标值，父亲的XY坐标值，从结点开始利用父亲的XY值遍历整个序列，看谁的XY和这里的对应就找到了父亲结点，依次进行，但是这样的复杂度太高了吧。。。果断舍去。。。<br>好的，下面就介绍杰哥给的几种复杂度低的算法</p>
<h4 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h4><p>这样怎么说呢，有点类似树的双亲孩子表示法，建立一个数组，里面装着每一个结点，结点后面跟着父亲结点在数组里面的下标值，就是一个结构体数组，通过每一个结点里面的父亲结点在数组里面的下标值就可以找到父亲结点了，通过在数组里面存储下标来回溯，很棒呀。<br><img src="https://img-blog.csdnimg.cn/20200317202726340.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Input:默认以(0,0)为起点，(4,4)为终点，随便改一下就行 </span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">...##</span></span><br><span class="line"><span class="comment">##.##</span></span><br><span class="line"><span class="comment">....#</span></span><br><span class="line"><span class="comment">.##.#</span></span><br><span class="line"><span class="comment">.....*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> x,y,lastId;</span><br><span class="line">&#125;que[N*N];<span class="comment">//最大有N*N个结点，没有墙全是路 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(node cur)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(cur.lastId!=<span class="number">-1</span>)&#123; </span><br><span class="line">  Print(que[cur.lastId]);<span class="comment">//递归的算法，先找到第一个结点后输出值</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,cur.x,cur.y);<span class="comment">//先找后输出就是顺序，先输出后找就是逆序 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">int</span> L=<span class="number">1</span>,R=<span class="number">0</span>;</span><br><span class="line"> que[++R]=(node)&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">//lastId=-1表示没有父亲 </span></span><br><span class="line"> dis[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//(0,0)为起点 </span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">  node cur=que[L++];<span class="comment">//当前状态</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">   node nxt;</span><br><span class="line">   nxt.x=cur.x+dx[i];</span><br><span class="line">   nxt.y=cur.y+dy[i];</span><br><span class="line">   nxt.lastId=L<span class="number">-1</span>;<span class="comment">//当前状态的上一个状态在que数组中的下标为L-1 </span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(nxt.x==n<span class="number">-1</span>&amp;&amp;nxt.y==m<span class="number">-1</span>)&#123;<span class="comment">//(n-1,m-1)为终点 </span></span><br><span class="line">    Print(nxt);</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">map</span>[nxt.x][nxt.y]==<span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//无法通行 </span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(nxt.x&gt;=<span class="number">0</span>&amp;&amp;nxt.x&lt;n&amp;&amp;nxt.y&gt;=<span class="number">0</span>&amp;&amp;nxt.y&lt;m&amp;&amp;dis[nxt.x][nxt.y]==<span class="number">-1</span>)&#123;</span><br><span class="line">    que[++R]=nxt; </span><br><span class="line">    dis[nxt.x][nxt.y]=dis[cur.x][cur.y]+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">map</span>[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> BFS();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h3><p>我真的有点被这个算法惊讶到了<br>利用二维数组可以存储四个值，一般来数二维数组值可以存储三个值(x,y,本身点的信息),但是这里可以使用两个二维数组存储x,y,fx,fy的信息，分而和，和而找，既然知道了这四个信息，我们也就不难去回溯了<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;//还是和上面一样，(0,0)起点，(n-1,m-1)终点 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fax[N][N];</span><br><span class="line"><span class="keyword">int</span> fay[N][N];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;que;<span class="comment">//对列 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dis[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x!=<span class="number">-1</span>&amp;&amp;y!=<span class="number">-1</span>)&#123;</span><br><span class="line">  Print(fax[x][y],fay[x][y]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x,y);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line"> </span><br><span class="line"> que.push((node)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line"> dis[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//(0,0)为起点 </span></span><br><span class="line"> </span><br><span class="line"> fax[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"> fay[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">  node cur=que.front();<span class="comment">//当前状态</span></span><br><span class="line">  que.pop();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">   node nxt;</span><br><span class="line">   nxt.x=cur.x+dx[i];</span><br><span class="line">   nxt.y=cur.y+dy[i];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">map</span>[nxt.x][nxt.y]==<span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//无法通行 </span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(nxt.x&gt;=<span class="number">0</span>&amp;&amp;nxt.x&lt;n&amp;&amp;nxt.y&gt;=<span class="number">0</span>&amp;&amp;nxt.y&lt;m&amp;&amp;dis[nxt.x][nxt.y]==<span class="number">-1</span>)&#123;</span><br><span class="line">    que.push(nxt); </span><br><span class="line">    dis[nxt.x][nxt.y]=dis[cur.x][cur.y]+<span class="number">1</span>;</span><br><span class="line">    fax[nxt.x][nxt.y]=cur.x;</span><br><span class="line">    fay[nxt.x][nxt.y]=cur.y;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">map</span>[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> BFS();</span><br><span class="line"> Print(n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其他的简单的BFS一样，最为精华的我展示出来了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x!=<span class="number">-1</span>&amp;&amp;y!=<span class="number">-1</span>)&#123;</span><br><span class="line">  Print(fax[x][y],fay[x][y]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x,y);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>难以言语，分开来，合起来，分开来，再合起来….<br>道家的思想，</p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构视频知识点整理</title>
    <url>/orange-cat-win.github.io/2020/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%86%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/av83429114?p=18">王道数据结构传送门</a></p>
<h1 id="第一节-数据和算法"><a href="#第一节-数据和算法" class="headerlink" title="第一节.数据和算法"></a>第一节.数据和算法</h1><h2 id="常用时间复杂度大小关系"><a href="#常用时间复杂度大小关系" class="headerlink" title="常用时间复杂度大小关系"></a>常用时间复杂度大小关系</h2><p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2^)&lt;O(n^3^)&lt;O(2^n^)<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i=<span class="number">2</span>*i)&#123;</span><br><span class="line">    sum=sum+i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>满足条件：2^k^&lt;n    =&gt;    k&lt;log<del>2</del>n<br>时间复杂度 O(logn)   ==这里时间复杂度不考虑底数2==</p>
<h1 id="第二节-线性表"><a href="#第二节-线性表" class="headerlink" title="第二节.线性表"></a>第二节.线性表</h1><p>线性表是指具有相同数据类型的n个元素的有限序列</p>
<h2 id="线性表的顺序存储"><a href="#线性表的顺序存储" class="headerlink" title="线性表的顺序存储"></a>线性表的顺序存储</h2><h3 id="1-顺序表的存储方式"><a href="#1-顺序表的存储方式" class="headerlink" title="1.顺序表的存储方式"></a>1.顺序表的存储方式</h3><p>1.利用一组地址连续的存储单元，一次存储线性表中的数据元素，顺序存储的线性表也叫作顺序表<br>2.==loc(a<del>n</del>)=loc(a<del>1</del>)+(n-1)*d==    知道首元素的存储地址和每个数据的存储单元就可以知道顺序表中的每一个数据的存储位置，时间复杂度为O(1)，即为随机存取</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100<span class="comment">//静态</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> elemtype</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    elemtype data[maxsize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;Sqlsit;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> elemtype;<span class="comment">//动态</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    elemtype *data;<span class="comment">//创建一个指针域</span></span><br><span class="line">    <span class="keyword">int</span> maxsize,length;</span><br><span class="line">&#125;Seqlist;</span><br><span class="line">Seqlist L;</span><br><span class="line">L.data=(elemtype)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(elemtype)*initsize);</span><br><span class="line"><span class="comment">//按照给定的需要的initsize大小动态的分配空间给顺序表</span></span><br><span class="line"><span class="comment">//这里要注意：链表和这个动态分配的顺序表的区别</span></span><br></pre></td></tr></table></figure>
<p>==***== 动态分配并不是链式存储，同样还是属于顺序存储空间，只是分配的空间大小可以在运行时决定</p>
<h2 id="2-C动态分配空间知识复习"><a href="#2-C动态分配空间知识复习" class="headerlink" title="2.C动态分配空间知识复习"></a>2.C动态分配空间知识复习</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> *p;</span><br><span class="line">p=(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(<span class="number">30</span>*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br></pre></td></tr></table></figure>
<p>1.首先开辟了30个double类型的空间，然后把p指向这个空间的位置。在这里的指针是指向第一个double值并非我们所有开辟的30个double的空间，这就和数组一样，指向数组的指针式指向数组首元素的地址，并非整个数组的元素。所以，在这里我们的操作也和数组是一样的， p[0]就是第一个元素，p[2]就是第二个元素。<br>2.当我们使用malloc()开辟完内存空间以后，我们所要考虑的就是释放内存空间，在这里，C给我们提供了free()函数。free()的參数就是malloc()函数所返回的地址，释放先前malloc()函数所开辟的空间，free函数也是必不可缺少的函数。</p>
<h2 id="3-顺序表的基本操作"><a href="#3-顺序表的基本操作" class="headerlink" title="3.顺序表的基本操作"></a>3.顺序表的基本操作</h2><p>1.线性表的插入：在  1&lt;= i &lt;=length+1 的位置都可以进行插入操作，如果 i 的输入不合法则返回 false,否则将顺序表的第 i 个元素及其以后的元素都向右移动一个位置，腾出位置给新插入的元素，表长加1，插入成功，返回 true</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">listinsert</span><span class="params">(sqlsit &amp;L,<span class="keyword">int</span> i,elemtype e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>||L.length&gt;=maxsize)</span><br><span class="line">        <span class="keyword">return</span> fasle;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=L.length;j&gt;=i;j--)</span><br><span class="line">        L.data[j+<span class="number">1</span>]=L.data[j];<span class="comment">//定义表的第一个元素存储在数组data第一个空间</span></span><br><span class="line">    L.data[i]=e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表插入的算法分析：<br>最好情况：直接在表尾进行插入，数据不需要移动，时间复杂度为O(1)<br>最坏情况：在表头进行插入，数据需要移动 n次，时间复杂度为O(n)<br>平均情况：概率为从插入第一个位置到插入最后的n+1个位置 p = 1/(n+1)<br>对应着平均移动次数 n- i+1，将概率和平均移动次数相乘，从i=1到i=n+1进行求和，最后为 n/2，时间复杂度为O(n)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sqlistdelete</span><span class="params">(sqlist &amp;L,<span class="keyword">int</span> i,elemtype &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e=L.data[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=L.length;j++)</span><br><span class="line">        L.data[j]=L.data[j+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表删除的算法分析：<br>最好情况：直接在表尾进行删除，数据不需要移动，时间复杂度为O(1)<br>最坏情况：在表头进行删除，数据需要移动 n-1 次，时间复杂度为O(n)<br>平均情况：概率为从插入第一个位置到插入最后 n 的位置 p = 1/n<br>对应着平均移动次数 n- i，将概率和平均移动次数相乘，从i=1到i=n+1进行求和，最后为 (n-1)/2，时间复杂度为O(n)</p>
<p><del>顺序表的优缺点分析</del><br>|  优点|  缺点|<br>|–|–|<br>| 存储密度大，无需给存储数据关系增添额外的逻辑结构| 删除和插入需要移动大量的数据元素 |<br>|随机存取，想在哪里存数据或者去数据均可|对存储空间要求高，容易产生空间碎片|</p>
<h2 id="线性表的链式存储"><a href="#线性表的链式存储" class="headerlink" title="线性表的链式存储"></a>线性表的链式存储</h2><h3 id="1-单链表的存储方式"><a href="#1-单链表的存储方式" class="headerlink" title="1.单链表的存储方式"></a>1.单链表的存储方式</h3><p>1.用一组任意的存储单元来存储这些数据信息，为了建立起来线性存储关系，每一个链表的结点不仅存放自身的数据信息，还存放了下一个数据信息的地址，这种方式称之为单链表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>&#123;</span></span><br><span class="line">    elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Lnode,*linklist;</span><br><span class="line"><span class="comment">//该结构体命名为Lnode,指向这个结构体的指针类型称之为*linklist</span></span><br></pre></td></tr></table></figure>
<p>2.通常用头指针来表示一个单链表，知道了头指针就知道了第一个结点的信息，这整条单链表也都知道了，linklist L，L则为这个单链表的头指针<br>3.在单链表的第一个结点前面附加一个一个不存储任何信息的空节点，称之为头结点，设立头结点可以处理操作方便，删除第一个元素结点或者在第一元素结点的后面增加结点都和其他的结点的操作一致，无论链表是否为空，头指针是指向头结点的非空指针。</p>
<blockquote>
<p>==头指针L(指向第一个结点的地址)  —&gt;  空的头结点 —&gt; 带有存储信息的结点==<br>不管带不带头结点，头指针始终指向链表的第一个结点，尾指针始终指向链表的最后一个节点，而头结点是带头结点链表中的第一个结点，结点内不存储信息，linklist L,则头指针L就代表一个单链表，通过头指针就能找到头结点</p>
</blockquote>
<p>4.如何获取单项链表的头结点<br>A.声明链表后，马上定义一个头指针，指向链表的头结点，这样，不管程序运行到哪儿，都可以通过访问头指针来得到头结点。<br>B.定义单独的头结点，不赋值，永远只作为类似标志的性质，以后通过它访问整个链表，即链表第一个结点为头结点-&gt;Next<br>C.将单向链表制作为循环链表，在头结点设置特殊值，永远往一个方向找，一旦找到特殊值，即为找到头结点。</p>
<h3 id="2-单链表的基本操作"><a href="#2-单链表的基本操作" class="headerlink" title="2.单链表的基本操作"></a>2.单链表的基本操作</h3><h5 id="1-创建单链表之头插法"><a href="#1-创建单链表之头插法" class="headerlink" title="1.创建单链表之头插法"></a>1.创建单链表之头插法</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">linklist <span class="title">creatlinklist</span><span class="params">(linklist &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    linklist s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    L=(linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">        s.data=x;</span><br><span class="line">        s-&gt;next=L-&gt;next;<span class="comment">//让s后面与头结点后面的结点相连</span></span><br><span class="line">        L-&gt;next=s;<span class="comment">//让s连接在头结点后面</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的结点都是插在头结点后面，生成的链表数据顺序与输入的数据顺序相反<br>==创建结点指针后,linklist p,如果涉及data数值的改变==<br>==必须先向空间申请内存==<br>==p=(linklist)malloc(sizeof(Lnode));==<br>==如果仅仅只作为一个指针前后移动的话==<br>==则无需向空间申请内存==</p>
<h5 id="2-创建单链表之尾插法"><a href="#2-创建单链表之尾插法" class="headerlink" title="2.创建单链表之尾插法"></a>2.创建单链表之尾插法</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">linklist <span class="title">creatlinklist</span><span class="params">(linklist &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    L=(linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">    linklist s,r=L;<span class="comment">//r为表尾元素,s为新结点</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">        s.data=x;</span><br><span class="line">        r-&gt;next=s;<span class="comment">//表尾元素的下一个值为s</span></span><br><span class="line">        r=s;<span class="comment">//再移动表尾元素</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;<span class="comment">//保证最后的表尾元素下一值为空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾插法读入数据的顺序和输入数据的顺序一致</p>
<h5 id="3-查找单链表之按序号查找"><a href="#3-查找单链表之按序号查找" class="headerlink" title="3.查找单链表之按序号查找"></a>3.查找单链表之按序号查找</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">linklist <span class="title">searchlinlist</span><span class="params">(linklist L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    linklist p=L-&gt;next;<span class="comment">//p从头结点的下一位结点开始</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;i&amp;&amp;p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里默认头结点为i=0的结点</p>
<h5 id="4-查找单链表之按值查找"><a href="#4-查找单链表之按值查找" class="headerlink" title="4.查找单链表之按值查找"></a>4.查找单链表之按值查找</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">linklist <span class="title">searchlinlist</span><span class="params">(linklist L,elemtype e)</span></span>&#123;</span><br><span class="line">    linklist p=L-&gt;next;<span class="comment">//p从头结点的下一位结点开始</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p.data!=e)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">    <span class="comment">//要不p=NULL跳出要不p.data=e跳出，直接返回p就行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-插入单链表的结点"><a href="#5-插入单链表的结点" class="headerlink" title="5.插入单链表的结点"></a>5.插入单链表的结点</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertlinlist</span><span class="params">(linklist &amp;L,elemtype e，<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    linklist r,s;</span><br><span class="line">    r=searchlinlist(L,i<span class="number">-1</span>);<span class="comment">//找到i-1的结点的位置</span></span><br><span class="line">    <span class="keyword">if</span>(r==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s=(linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">    s.data=e;</span><br><span class="line">    s-&gt;next=r-&gt;next;</span><br><span class="line">    r-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-删除单链表的结点"><a href="#6-删除单链表的结点" class="headerlink" title="6.删除单链表的结点"></a>6.删除单链表的结点</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deletelinlist</span><span class="params">(linklist &amp;L，<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    linklist r,s;</span><br><span class="line">    r=searchlinlist(L,i<span class="number">-1</span>);<span class="comment">//找到i-1的结点的位置</span></span><br><span class="line">    <span class="keyword">if</span>(r==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s=r-&gt;next;<span class="comment">//找到i的结点的位置</span></span><br><span class="line">    r-&gt;next=s-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-双链表"><a href="#3-双链表" class="headerlink" title="3.双链表"></a>3.双链表</h3><h5 id="1-双链表的存储方式"><a href="#1-双链表的存储方式" class="headerlink" title="1.双链表的存储方式"></a>1.双链表的存储方式</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dnode</span>&#123;</span></span><br><span class="line">    elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dnode</span> *<span class="title">next</span>,*<span class="title">prior</span>;</span></span><br><span class="line">&#125;Dnode,*Dinklist;</span><br></pre></td></tr></table></figure>
<p>相对于单链表而言，双链表就是在单链表的基础上面增加一个前驱指针,可以通过前驱指针找到前面的结点，典型的消耗空间换取时间的例子</p>
<h5 id="2-双链表的按序号取值"><a href="#2-双链表的按序号取值" class="headerlink" title="2.双链表的按序号取值"></a>2.双链表的按序号取值</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">linklist <span class="title">searchDinlist</span><span class="params">(Dinklist L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Dinklist p=L-&gt;next;<span class="comment">//p从头结点的下一位结点开始</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;i&amp;&amp;p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-双链表的插入结点"><a href="#3-双链表的插入结点" class="headerlink" title="3.双链表的插入结点"></a>3.双链表的插入结点</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertDinlist</span><span class="params">(Dinklist &amp;L,elemtype e，<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    Dinklist r,s;</span><br><span class="line">    r=searchDinlist(L,i<span class="number">-1</span>);<span class="comment">//找到i-1的结点的位置</span></span><br><span class="line">    <span class="keyword">if</span>(r==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s=(linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">    s.data=e;</span><br><span class="line">    r-&gt;next-&gt;prior=s;</span><br><span class="line">    s-&gt;next=r-&gt;next;</span><br><span class="line">    r-&gt;next=s;</span><br><span class="line">    s-&gt;prior=r;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-双链表的删除结点"><a href="#4-双链表的删除结点" class="headerlink" title="4.双链表的删除结点"></a>4.双链表的删除结点</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteDinlist</span><span class="params">(Dinklist &amp;L，<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    Dinklist r,s;</span><br><span class="line">    r=searchDinlist(L,i<span class="number">-1</span>);<span class="comment">//找到i-1的结点的位置</span></span><br><span class="line">    <span class="keyword">if</span>(r==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s=r-&gt;next;<span class="comment">//找到i的结点的位置</span></span><br><span class="line">    r-&gt;next=s-&gt;next;</span><br><span class="line">    s-&gt;next-&gt;prior=r;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>理解还有困难的话可以尝试画图看看哦</del></p>
<h4 id="3-循环单链表"><a href="#3-循环单链表" class="headerlink" title="3.循环单链表"></a>3.循环单链表</h4><p>1.循环单链表在表中的最后一个元素的指针不再是指向NULL,而是改为指向头结点，从而整个链表形成一个环<br>2.从任何的一个节点出发都能访问到链表中的每一个元素<br>3.判空条件不是头结点的后继指针是否为空，而是判断头结点的后继指针是否等于头指针，等于的话头结点的后继指针指向自己，链表为空<br>4.可对循环单链表设立尾指针不设立头指针，设立尾指针既可以访问到尾结点的数值又可以访问到第一个结点的数值，头指针还需要遍历才能访问到最后一个节点的数值，尾指针是指向最后一个节点地址的指针</p>
<h4 id="4-循环双链表"><a href="#4-循环双链表" class="headerlink" title="4.循环双链表"></a>4.循环双链表</h4><p>1.循环双链表就是双链表首尾构成环<br>2.在循环双链表L中，尾指针的后继指针指向表头结点，头结点的前驱指针指向表尾结点<br>3.当循环链表为空时，其头结点的next域和prior域都等于L</p>
<h4 id="4-静态链表"><a href="#4-静态链表" class="headerlink" title="4.静态链表"></a>4.静态链表</h4><p>1.静态链表是借助数组来表示的存储结构，其中结构体里面也有data和next,data域借助数组来存放,而next域借助结点数组存放的数组下标来寻找，就相当于next域存放的是这个data域下面一个data域的数组下标<br>2.静态链表中以next为-1作为其结束的标志<br>3.静态链表的操作只需要修改数组的指针，不需要移动元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> elemtype</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    elemtype data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;slinklist[maxsize];</span><br></pre></td></tr></table></figure>
<h1 id="第三节-栈"><a href="#第三节-栈" class="headerlink" title="第三节.栈"></a>第三节.栈</h1><p>栈(stack)：只允许在一端进行插入或删除操作的线性表<br>栈顶(top)：栈中允许进行插入和删除的那一段<br>栈底(bottom)：固定的，不允许进行插入和删除的那一端<br>栈运行的规则：FILO（后进先出）</p>
<h2 id="1-顺序栈"><a href="#1-顺序栈" class="headerlink" title="1.顺序栈"></a>1.顺序栈</h2><p>栈的顺序存储结构称之为顺序栈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    elemtype data[maxsize];</span><br><span class="line">    <span class="keyword">int</span> top;<span class="comment">//以i=0的数组下标作为栈底</span></span><br><span class="line">&#125;sqstack;</span><br></pre></td></tr></table></figure>
<p>top值不可以超过maxsize<br>判断栈空的条件通常为   top==-1<br>判断栈满的条件通常为   top==maxszie-1<br>栈中元素为  top+1<br>也就是从  i=0 作为栈底开始存数据一直到  i=maxsize-1 结束，最大的数据能存maxszie个数据，当前数据为 top+1个数据</p>
<h4 id="顺序栈的判空"><a href="#顺序栈的判空" class="headerlink" title="顺序栈的判空"></a>顺序栈的判空</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stackempty</span><span class="params">(sqstack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="顺序栈的进栈"><a href="#顺序栈的进栈" class="headerlink" title="顺序栈的进栈"></a>顺序栈的进栈</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(sqstack &amp;S,elemtype e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==maxszie<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s.data[++top]=e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="顺序栈的出栈"><a href="#顺序栈的出栈" class="headerlink" title="顺序栈的出栈"></a>顺序栈的出栈</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(sqstack &amp;S,elemtype &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=s.data[top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="顺序栈的读取栈顶元素"><a href="#顺序栈的读取栈顶元素" class="headerlink" title="顺序栈的读取栈顶元素"></a>顺序栈的读取栈顶元素</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(sqstack &amp;S,elemtype &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=s.data[top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-共享栈"><a href="#2-共享栈" class="headerlink" title="2.共享栈"></a>2.共享栈</h2><p>顺序栈存储空间大小需要实现开辟好，会造成每个栈的利用率并不是很高，可以将两个栈进行合并存储在一个数组里面称之为共享栈<br>| 栈1底 |top1 |  | | …  | top2 | 栈2底 |<br>|–|–|–|–|–|–|–|<br>| 0 |1 | 2 |3 | …  | maxsize-2| maxsize-1 |<br>由图不难看出<br>栈1底  = 0——–top1数值越大栈1元素越多<br>栈2底  = maxsize-1——–top2数值越小栈2元素越多<br>栈满的判断条件  <strong>top2=top1+1</strong> </p>
<h4 id="共享栈的定义"><a href="#共享栈的定义" class="headerlink" title="共享栈的定义"></a>共享栈的定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    elemtype data[maxsize];</span><br><span class="line">    <span class="keyword">int</span> top1;</span><br><span class="line">    <span class="keyword">int</span> top2;</span><br><span class="line">&#125;sqdoublestack;</span><br></pre></td></tr></table></figure>
<h4 id="共享栈的入栈操作"><a href="#共享栈的入栈操作" class="headerlink" title="共享栈的入栈操作"></a>共享栈的入栈操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(sqdoublestack &amp;s,elemtype e,<span class="keyword">int</span> stacknum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top1+<span class="number">1</span>=s.top2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(stacknum==<span class="number">1</span>)</span><br><span class="line">        s.data[++top1]=e;</span><br><span class="line">    <span class="keyword">if</span>(stacknum==<span class="number">2</span>)</span><br><span class="line">        s.data[--top2]=e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这里设置stacknum标识</span></span><br><span class="line"><span class="comment">//当stacknum=1时对栈1进行操作,当stacknum=2时对栈2进行操作</span></span><br></pre></td></tr></table></figure>
<h4 id="共享栈的出栈操作"><a href="#共享栈的出栈操作" class="headerlink" title="共享栈的出栈操作"></a>共享栈的出栈操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(sqdoublestack &amp;s,elemtype &amp;x,<span class="keyword">int</span> stacknum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top1==<span class="number">-1</span>||s.top2==maxsize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(stacknum==<span class="number">1</span>)</span><br><span class="line">        x=s.data[top--];</span><br><span class="line">    <span class="keyword">if</span>(stacknum==<span class="number">2</span>)</span><br><span class="line">        x=s.data[top++];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-链式栈"><a href="#3-链式栈" class="headerlink" title="3.链式栈"></a>3.链式栈</h2><p>1.可以用链表的方式来实现栈<br>2.对于一个单链表来讲,可以将头指针当做栈顶指针，所以栈顶放在单链表的头部，栈底则为最后一个元素<br>3.链式栈一般不存在栈满的情况，可以在内存允许的范围下面无限进栈<br>4.判断栈空的条件通常为top==NULL</p>
<h4 id="链式栈的定义"><a href="#链式栈的定义" class="headerlink" title="链式栈的定义"></a>链式栈的定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">snode</span>&#123;</span></span><br><span class="line">    elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;snode,*slink;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    slink top;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;linkstack;</span><br></pre></td></tr></table></figure>
<p>我自己的理解就是snode的作用就是盖房子，linkstack的作用是按照snode的标准该一个房子作为头房子，头房子后面还可以连接房子，用count来记录头房子后面总共还有多少房子</p>
<h4 id="链式栈的进栈"><a href="#链式栈的进栈" class="headerlink" title="链式栈的进栈"></a>链式栈的进栈</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(linkstack &amp;s,elemtype e)</span></span>&#123;</span><br><span class="line">    slink p;<span class="comment">//创造一个新的房子</span></span><br><span class="line">    p=(slink)<span class="built_in">malloc</span>(sizoef(snode));</span><br><span class="line">    p.data=e;</span><br><span class="line">    p-&gt;next=s.top;<span class="comment">//新房子的后继指向头房子，连在头房子前面</span></span><br><span class="line">    】</span><br><span class="line">    s.top=p;<span class="comment">//将新房子命名为头房子</span></span><br><span class="line">    s.count++;<span class="comment">//房子数量加加</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有点类似于头插法哦，在链表的头部插入元素</p>
<h4 id="链式栈的出栈"><a href="#链式栈的出栈" class="headerlink" title="链式栈的出栈"></a>链式栈的出栈</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(linkstack &amp;s,elemtype &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=s-&gt;top-&gt;data;</span><br><span class="line">    slink p=s-&gt;top;<span class="comment">//保存栈顶的地址</span></span><br><span class="line">    s-&gt;top=s-&gt;top-&gt;next;<span class="comment">//将栈顶向下移</span></span><br><span class="line">    <span class="built_in">free</span>(p);释放栈顶元素</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第四节-队列"><a href="#第四节-队列" class="headerlink" title="第四节.队列"></a>第四节.队列</h1><p>队列(queue)：只允许在一端进行插入或删除操作的线性表<br>队头(front):允许删除的一端，或者称为队首<br>队尾(rear):允许插入的一端<br>队列的操作特点是：先进先出（FIFO）first in first out<br>一般来说队首指向队列的第一个元素，队尾指向队列最后的一个元素下一个位置</p>
<h2 id="1-顺序队列"><a href="#1-顺序队列" class="headerlink" title="1.顺序队列"></a>1.顺序队列</h2><h4 id="A-顺序队列设想1"><a href="#A-顺序队列设想1" class="headerlink" title="A.顺序队列设想1"></a>A.顺序队列设想1</h4><p>用数组来实现队列，把队首放在数组下标为0的位置，队尾放在最后一个元素的后面一个数组下标的位置，那么入队的话就只需要在数组最大限制个数内把队尾下标赋值，队尾加加即可，出队的话把队首元素删除，每一个元素都向前移动，队首不变还是数组下标为0 的位置，队尾减减即可，队空条件是就是队首等于队尾等于数组下标为0，但是可能出队操作过于麻烦</p>
<h4 id="B-顺序队列设想2"><a href="#B-顺序队列设想2" class="headerlink" title="B.顺序队列设想2"></a>B.顺序队列设想2</h4><p>还是用数组来实现队列，把队首和队尾不再固定，入队还是填入元素，队尾加加，出队就是队首移动加加即可，但是发现随着队首元素的不断移动，不断的入队，这个队列能存放的数据越来越小，我们可以想象把数组给掰弯，如果达到最大数组限制范围，继续入队的话我们可以把队尾指针指向队头移动空余的前面那些数组上面，就好比一个环，这样我们引出了循环队列、</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    elemtype data[maxsize];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;sqqueue</span><br></pre></td></tr></table></figure>

<h2 id="2-循环队列"><a href="#2-循环队列" class="headerlink" title="2.循环队列"></a>2.循环队列</h2><p>1.把数组掰弯，形成一个环，rear指针到了下标为最大数组限制的地方还能回到下标为0的地方，这样首尾相连的顺序存储的队列称之为循环队列<br>2.那么数组并不能被掰弯，我们想到了取余操作，超出了maxsize后对maxsize取余就能使数回到前面来，由此可知<br>==入队:rear=(rear+1)%maxsize==<br>==出队:front=(front+1)%maxsize==<br>3.那么问题又来了，当队满的情况下，rear指针和front指针重合是，我们怎么判断是这个队列满的情况还是这个队列空的情况？<br>队列空:rear=front 队列满:rear=front   ????</p>
<h4 id="A-解决方案一"><a href="#A-解决方案一" class="headerlink" title="A.解决方案一"></a>A.解决方案一</h4><p>我们可以设置一个flag的表示，当入队的时候顺便令flag=1,当出队的时候顺便令flag=0,那么当队头指针等于队尾指针的时候，如果flag=1，此时有入队操作应该是队列满，如果当flag=0，此时有出队操作应该是队列空</p>
<h4 id="B-解决方案二（重点）"><a href="#B-解决方案二（重点）" class="headerlink" title="B.解决方案二（重点）"></a>B.解决方案二（重点）</h4><p>我们可以规定队列当队列中仍还有一个空留单元的时候，队列为满的状态，队列为空的状态是rear=front<br>| 2 |3  |4|   |  5|<br>|–|–|–|–|–|<br>|  |  |  rear|   |  front|<br>可以看到此时我们就规定队列为满<br>==那么此时队列为满的条件就为(rear+1)maxsize=front==<br>==队列为空的条件就是 rear=front==<br>==队列中还有的元素为 (rear-front+maxsize)%maxsize==</p>
<h4 id="顺序队列入队操作"><a href="#顺序队列入队操作" class="headerlink" title="顺序队列入队操作"></a>顺序队列入队操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">enqueue</span><span class="params">(sqqueue &amp;q,elemtype e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((q.rear+<span class="number">1</span>)%maxsize==q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    q.data[q.rear]=e;</span><br><span class="line">    rear=(rear+<span class="number">1</span>)%maxsize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="顺序队列出队操作"><a href="#顺序队列出队操作" class="headerlink" title="顺序队列出队操作"></a>顺序队列出队操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dequeue</span><span class="params">(sqqueue &amp;q,elemtype &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q.rear==q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=q.data[q.front];</span><br><span class="line">    front=(front+<span class="number">1</span>)%maxsize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-链式队列"><a href="#3-链式队列" class="headerlink" title="3.链式队列"></a>3.链式队列</h2><p>1.队列的链式存储结构，其实就是线性表的单链表，只不过需要加一点限制条件，只能在表尾插入元素，表头删除元素<br>2.为了操作方便，我们分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向尾结点</p>
<h4 id="1-链式队列的定义"><a href="#1-链式队列的定义" class="headerlink" title="1.链式队列的定义"></a>1.链式队列的定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linknode</span>&#123;</span></span><br><span class="line">    elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;linknode,*linklist;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    linknode *front,*rear;</span><br><span class="line">    <span class="comment">//linklist front,rear;两种均可</span></span><br><span class="line">&#125;linkqueue;</span><br></pre></td></tr></table></figure>
<h4 id="2-链式队列的入队操作"><a href="#2-链式队列的入队操作" class="headerlink" title="2.链式队列的入队操作"></a>2.链式队列的入队操作</h4><p>在队尾指针进行结点插入操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">enlinkqueue</span><span class="params">(linkqueue &amp;q,elemtype m)</span></span>&#123;</span><br><span class="line">    linknode *s;</span><br><span class="line">    s=(linklist)mallco(<span class="keyword">sizeof</span>(linknode));</span><br><span class="line">    <span class="comment">//s=(linknode *)mallco(sizeof(linknode));两种均行</span></span><br><span class="line">    s-&gt;data=m;</span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    q.rear-&gt;next=s;</span><br><span class="line">    q.rear=s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==这里要注意q的元素是以.的形式表示，s的元素是以-&gt;的形式表示==</p>
<h4 id="3-链式队列的出队操作"><a href="#3-链式队列的出队操作" class="headerlink" title="3.链式队列的出队操作"></a>3.链式队列的出队操作</h4><p>在队头指针指向的头结点的后继元素进行结点删除操作，并将头结点的后面元素改为头结点后继元素的后继元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dequeue</span><span class="params">(linkqueue q,elemtype &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q.front=q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=q.front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>(q.front-&gt;next==q.rear)</span><br><span class="line">    &#123;    </span><br><span class="line">        q.rear=q.front;</span><br><span class="line">        <span class="built_in">free</span>(q.front-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    q.front-&gt;next=q.front-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q.front-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里特别要注意当只有一个元素的时候，如果直接删除头结点的后继结点的话，会使队尾指针也被删除了，要先修改一下这个队尾指针再进行删除</p>
<h2 id="3-双端队列"><a href="#3-双端队列" class="headerlink" title="3.双端队列"></a>3.双端队列</h2><p>1.双端队列是指两端都可以进行入队和出队操作的队列<br>两端就分别命名为前端和后端<br>2.输入受限制的双端队列：一端只能输出一端都能输出和输入的双端队列<br>3.输出受限的双端队列：一端只能输入一端都能输出和输入的双端队列</p>
<h1 id="第五节-栈的应用"><a href="#第五节-栈的应用" class="headerlink" title="第五节.栈的应用"></a>第五节.栈的应用</h1><h2 id="1-括号匹配问题"><a href="#1-括号匹配问题" class="headerlink" title="1.括号匹配问题"></a>1.括号匹配问题</h2><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p><a href="https://blog.csdn.net/HDong99/article/details/80725281">switch的用法
</a><br>直接点进去看看了解了解即可</p>
<h4 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> s;</span><br><span class="line">    initstack(s);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> a=str[i];</span><br><span class="line">        <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">            <span class="keyword">case</span><span class="number">&#x27;</span>(<span class="string">&#x27;:</span></span><br><span class="line">            case&#x27;[&#x27;:</span><br><span class="line">                push(s,a);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span><span class="number">&#x27;</span>)<span class="string">&#x27;:</span></span><br><span class="line">                x=pop(s);</span><br><span class="line">                <span class="keyword">if</span>(x!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span><span class="number">&#x27;</span>]<span class="string">&#x27;:</span></span><br><span class="line">                x=pop(s);</span><br><span class="line">                <span class="keyword">if</span>(x!=<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(stackempty(s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法思想：如果是左括号的话，就入栈，如果是右括号的话就出栈，判断栈顶元素的左括号是否和右括号匹配，一直操作至字符串的最后一个元素，最后判断栈是否为空，不为空的话证明匹配不成功</p>
<h2 id="2-简单后缀表达式求值问题"><a href="#2-简单后缀表达式求值问题" class="headerlink" title="2.简单后缀表达式求值问题"></a>2.简单后缀表达式求值问题</h2><h2 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1.代码实现"></a>1.代码实现</h2><p><a href="https://blog.csdn.net/qq_20366761/article/details/70053813">C++栈的用法及栈的实现</a></p>
<p>在默认以#号结束<br>不超过9的正整数的简单后缀表达式四则求值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">CalPostfix</span><span class="params">(<span class="keyword">char</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1,num2,num,k=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;<span class="comment">//建立一个栈</span></span><br><span class="line">    <span class="keyword">while</span>(a[k]!=<span class="string">&#x27;#&#x27;</span>)<span class="comment">//看数组中元素的数量</span></span><br><span class="line">        k++;<span class="comment">//默认最后以#结束</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;a[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;<span class="comment">//这里的数组为字符数组</span></span><br><span class="line">            num=(<span class="keyword">int</span>)(a[i]-<span class="string">&#x27;0&#x27;</span>);<span class="comment">//要转化为整形的数字</span></span><br><span class="line">            s.push(num);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            num1=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            num2=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">char</span> b=a[i];</span><br><span class="line">            <span class="keyword">switch</span>(b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>+<span class="string">&#x27;:</span></span><br><span class="line">                    num=num2+num1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>-<span class="string">&#x27;:</span></span><br><span class="line">                    num=num2-num1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>*<span class="string">&#x27;:</span></span><br><span class="line">                    num=num2*num1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>/<span class="string">&#x27;:</span></span><br><span class="line">                    num=num2/num1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(num);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.top();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[N]=<span class="string">&quot;231*+9-#&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> x=CalPostfix(a);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>算法思想：建立一个栈，如果遇到整数就存储在栈中，遇到四则运算就取栈顶的两个元素进行四则运算，运算后的数再存储在栈顶，依次进行，则运算结果就是最后栈的栈顶<br>==一定要特别注意，取数的时候，第二个数作为开头进行计算==<br>==num2/num1 必须是这样的==</p>
<h2 id="2-将中缀表达式转换为后缀表达式"><a href="#2-将中缀表达式转换为后缀表达式" class="headerlink" title="2.将中缀表达式转换为后缀表达式"></a>2.将中缀表达式转换为后缀表达式</h2><h4 id="1-按照运算符的优先级将所有的运算符和运算数加括号"><a href="#1-按照运算符的优先级将所有的运算符和运算数加括号" class="headerlink" title="1.按照运算符的优先级将所有的运算符和运算数加括号"></a>1.按照运算符的优先级将所有的运算符和运算数加括号</h4><p>（5+20+1<em>3）/14<br>*==&gt;  (    (    (5+20)         +        (1*3))      /           14)</em>  </p>
<h4 id="2-将所有的运算符提取到括号的后面"><a href="#2-将所有的运算符提取到括号的后面" class="headerlink" title="2.将所有的运算符提取到括号的后面"></a>2.将所有的运算符提取到括号的后面</h4><p>==&gt;（((5 20)+（1 3）*)+14）/</p>
<h4 id="3-把括号的删除"><a href="#3-把括号的删除" class="headerlink" title="3.把括号的删除"></a>3.把括号的删除</h4><p>==&gt;5 20 + 1 3 * + 1 4 /</p>
<p>后缀表达式就转换完毕了</p>
<h2 id="3-多位数的后缀表达式求值"><a href="#3-多位数的后缀表达式求值" class="headerlink" title="3.多位数的后缀表达式求值"></a>3.多位数的后缀表达式求值</h2><p>只需要在字符数组里面的每一个字符中间添加一个空格<br>空格前后是数字或者运算符即可<br><a href="https://blog.csdn.net/he626shidizai/article/details/89890061">多位数的后缀表达式求值</a><br><del>去看一看这个博客就行啦</del> </p>
<h1 id="第六节-特殊矩阵的存储和压缩"><a href="#第六节-特殊矩阵的存储和压缩" class="headerlink" title="第六节.特殊矩阵的存储和压缩"></a>第六节.特殊矩阵的存储和压缩</h1><h2 id="1-普通矩阵的存储"><a href="#1-普通矩阵的存储" class="headerlink" title="1.普通矩阵的存储"></a>1.普通矩阵的存储</h2><h4 id="A-按行进行存储（行优先）"><a href="#A-按行进行存储（行优先）" class="headerlink" title="A.按行进行存储（行优先）"></a>A.按行进行存储（行优先）</h4><p>通俗理解就是先把二维数组一行一行的存储<br>| 7|  7|7|7|7|7|7|<br>|–|–|–|–|–|–|–|<br>| 7 | 7 |7|7|7|7|7|<br>|7|7|7|7|7|7|7|<br>|7|7|7|7||||<br>判断a<del>i</del>j<del>的存储位置<br>先判断在这个元素到已知元素中间有多少整行，再看已知元素到后面行截止有多少个单位，再看a</del>i<del>j</del>前面有多少个元素，加起来，看题目要求乘以每个存储单位的空间加上已知元素的存储地址即可</p>
<h4 id="B-按行进行存储（列优先）"><a href="#B-按行进行存储（列优先）" class="headerlink" title="B.按行进行存储（列优先）"></a>B.按行进行存储（列优先）</h4><p>通俗理解就是先把二维数组一列一列的存储<br>| 7|  7|7|7|7|7|7|<br>|–|–|–|–|–|–|–|<br>| 7 | 7 |7|7|7|7||<br>|7|7|7|7|7|7||<br>|7|7|7|7|7|7||<br>判断a<del>i</del>j<del>的存储位置<br>先判断在这个元素到已知元素中间有多少整列，再看已知元素到后面列截止有多少个单位，再看a</del>i<del>j</del>上面有多少个元素，加起来，看题目要求乘以每个存储单位的空间加上已知元素的存储地址即可<br>==要特别注意给的元素地址是这个元素的开头地址还是包含这个元素的元素截止后的地址，这个关系到要不要加这个元素的地址==</p>
<h2 id="2-对称矩阵的存储"><a href="#2-对称矩阵的存储" class="headerlink" title="2.对称矩阵的存储"></a>2.对称矩阵的存储</h2><p>满足a<del>i</del>j<del>=a</del>j<del>i</del>的一个矩阵<br>| 1 | 2 |3|4|5|6|7|<br>|–|–|–|–|–|–|–|<br>| 2 | 2 |3|4|5|6|7|<br>|3|3|3|4|5|6|7|<br>|4|4|4|4|5|6|7|<br>|5|5|5|5|5|6|7|<br>|6|6|6|6|6|6|7|<br>|7|7|7|7|7|7|7|<br>这种矩阵的存储思路就是只存储上三角矩阵或者只存储下三角矩阵，按照行优先的方式存储到一个一维数组里面</p>
<h4 id="A-存储下三角-默认"><a href="#A-存储下三角-默认" class="headerlink" title="A.存储下三角(默认)"></a>A.存储下三角(默认)</h4><p>就是先存1 2 2 3 3 3 4 4 4 4…7 7 7 7 7 7 7<br>总共需要(1+n)<em>n/2个存储单位，数组的最大下标为(1+n)<em>n/2-1<br>那么a<del>i</del>j~的位置<br>从1到i-1需要(1+i-1)</em>(i-1)/2个位置<br>在第i行需要j个位置<br>总共需要 (1+i-1)</em>(i-1)/2+j 个空间，对应数组下标是  k=(1+i-1)*(i-1)/2+j-1</p>
<h4 id="B-存储上三角"><a href="#B-存储上三角" class="headerlink" title="B.存储上三角"></a>B.存储上三角</h4><p>就是先存1 2 3 4 5 6 7…5 6 7 6 7 7<br>总共需要(1+n)*n/2个存储单位，数组的最大下标为(1+n)<em>n/2-1<br>相当是把下三角的 i 和 j 交换一下位置<br>那么a<del>i</del>j~<br>对应数组下标是 k=(1+j-1)</em>(j-1)/2+i-1</p>
<h2 id="3-三角矩阵的存储"><a href="#3-三角矩阵的存储" class="headerlink" title="3.三角矩阵的存储"></a>3.三角矩阵的存储</h2><p>矩阵的上三角或者下三角都是一个固定的常数<br>下三角矩阵<br>| 1 | 0 |0|0|0|0|0|<br>|–|–|–|–|–|–|–|<br>| 2 | 2 |0|0|0|0|0|<br>|3|3|3|0|0|0|0|<br>|4|4|4|4|0|0|0|<br>|5|5|5|5|5|0|0|<br>|6|6|6|6|6|6|0|<br>|7|7|7|7|7|7|7|<br>上三角矩阵<br>| 1 | 2 |3|4|5|6|7|<br>|–|–|–|–|–|–|–|<br>| 9 | 2 |3|4|5|6|7|<br>|9|9|3|4|5|6|7|<br>|9|9|9|4|5|6|7|<br>|9|9|9|9|5|6|7|<br>|9|9|9|9|9|6|7|<br>|9|9|9|9|9|9|7|<br>先按照行优先的存储方式存储那个三角矩阵，最后另外那一边的常数存储在这个一维数组的最后面<br>总共在一维数组里面存储的元素有(1+n)*n/2+1个元素，数组的最大下标为(1+n)*n/2</p>
<p>下三角矩阵和对称矩阵的下三角存储方式是一样的<br>那么a<del>i</del>j~的位置<br>从1到i-1需要(1+i-1)<em>(i-1)/2个位置<br>在第i行需要j个位置<br>总共需要 (1+i-1)</em>(i-1)/2+j 个空间，对应数组下标是  k=(1+i-1)*(i-1)/2+j-1<br>对于上三角元素存在k=(1+n)*n/2的地方即可</p>
<p>对于上三角矩阵来说<br>那么a<del>i</del>j~的位置<br>第一行有n个元素<br>第二行有n-1个元素<br>第三行有n-3个元素<br>….<br>第i-1行有n-(i-1)个元素<br>第i行有j-i+1个元素<br>总共是第 (n+n-(i-1))<em>(i-1)/2+j-i+1的元素<br> 对应的数组下标为 k=(n+n-(i-1))</em>(i-1)/2+j-i</p>
<h2 id="4-三对角矩阵的存储"><a href="#4-三对角矩阵的存储" class="headerlink" title="4.三对角矩阵的存储"></a>4.三对角矩阵的存储</h2><p>对对三对角矩阵的每一个元素a<del>i</del>j<del>来讲,如果 |i-j|&gt;1时，则a</del>i<del>j</del>=0<br>| 1 | 2 |0|0|0|0|0|<br>|–|–|–|–|–|–|–|<br>| 2 | 2 |3|0|0|0|0|<br>|0|3|3|4|0|0|0|<br>|0|0|4|4|5|0|0|<br>|0|0|0|5|5|6|0|<br>|0|0|0|0|6|6|7|<br>|0|0|0|0|0|7|7|<br>按照行优先的顺序存储每一个不为0的元素的值在一个一维数组里面<br>对于三对角矩阵来说</p>
<p>那么a<del>i</del>j~的位置<br>第一行有2个元素<br>第二行有j-i+1个元素<br>除去第一行和最后一行 还有(i-2)*3个元素<br>总共有 2+(i-2)*3+j-i+1个元素<br>对应数组的下标为k=2+(i-2)*3+j-i</p>
<p>那么排在第k个位置的元素<br>排在第k个数组的位置,实际上有k+1个元素，前面还有k个元素<br>除去第一行的两个元素 还有k-2个元素<br>除去最后一行 还有[(k-2)/3]（向下取余）行<br>总共有i=[(k-2)/3+1+1] (向下取余)行<br>怎么说呢<br>满足这个能取余的一定不是最后一行，最后一行向下取余一定没有<br>那么第i-1行有 2+(i-1)*3 个元素，看k+1个元素前面还有（k+1)- 2+(i-1)<em>3 个元素，这个数值（k+1)-(2+(i-1)*3）意思就是第i行非零元素有这么多元素<br>那么第i行都有i-2个非零元素，观察那个矩阵可以得到<br>所以   j=(k+1)-(2+(i-1)*3)+i-2<br>化简整理 i=[(k+1)/3+1] (向下取余)   j=k-2</em>i+3<br>多理解理解 不要背公式 遇到题直接上去推就行<br>OK啦！fight!    fight!</p>
<h1 id="第七节-树"><a href="#第七节-树" class="headerlink" title="第七节.树"></a>第七节.树</h1><p>ps:树和图上课的时候没太学好<br>王道的树我前几章有点看着吃力，我换成了讲解比较详细的青岛大学的王卓的树和图，准备做那里的笔记<br><a href="https://www.bilibili.com/video/av82837069?p=76">青岛大学王卓数据结构传送门</a></p>
<h2 id="1-树的定义"><a href="#1-树的定义" class="headerlink" title="1.树的定义"></a>1.树的定义</h2><p>树是n个结点的有限集合，当n=0时，此数为一棵空树，当n&gt;0时，有且仅有一个根结点，其余结点为m个互不相交的有限集T1,T2,T3…T<del>m</del> ，其中每一个集合本身又是一棵树，并称为根的子树</p>
<h2 id="2-树的基本术语"><a href="#2-树的基本术语" class="headerlink" title="2.树的基本术语"></a>2.树的基本术语</h2><p><img src="https://img-blog.csdnimg.cn/20200211160701387.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="https://www.processon.com/diagrams">画图工具传送门</a></p>
<h4 id="1-树"><a href="#1-树" class="headerlink" title="1.树"></a>1.树</h4><p>树的根结点：非空树中无前驱的结点<br>结点的度：结点拥有的子树的数量<br>树的度：树中所有结点的度的最大值<br>度=0：叶子结点，终端结点<br>度！=0：分支结点，非终端结点<br>内部结点：除了根结点之外的非终端结点<br>树的层次：根结点为第一层，依次往下增加<br>树的深度（高度）：这棵树的最大的层次<br>森林：m(m&gt;=0)棵互不相交的树的集合<br>树一定是森林，森林不一定是树<br>如图可知：<br>度(树)=3，度(A)=3，度(B)=2，度(G)=0，度(H)=1<br>根结点为A，叶子结点为K，分支结点就是除了叶子结点和根结点的所有结点<br>树有4层，树的深度为4</p>
<h4 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2.二叉树"></a>2.二叉树</h4><p>所有数都可以转换为唯一二叉树<br>二叉树的左子树和右子树不能颠倒<br>二叉树并不是树特殊情况<br>具有两个节点的二叉树有两种状态<br>具有两个节点的树只有一种状态<br><img src="https://img-blog.csdnimg.cn/20200211162523826.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>有三个节点的二叉树有五种不同的状态<br>有三个节点的树有两种不同的状态<br>二叉树有五种不同状态<br>空树，根和空的左右子树，根和左子树，根和右子树，根和左右子树</p>
<h2 id="3-二叉树的性质和存储特性"><a href="#3-二叉树的性质和存储特性" class="headerlink" title="3.二叉树的性质和存储特性"></a>3.二叉树的性质和存储特性</h2><h4 id="1-二叉树的性质"><a href="#1-二叉树的性质" class="headerlink" title="1.二叉树的性质"></a>1.二叉树的性质</h4><h6 id="A-在二叉树的第i层上面至多有2-i-1-个结点，至少有1个结点"><a href="#A-在二叉树的第i层上面至多有2-i-1-个结点，至少有1个结点" class="headerlink" title="A.在二叉树的第i层上面至多有2^i-1^个结点，至少有1个结点"></a>A.在二叉树的第i层上面至多有2^i-1^个结点，至少有1个结点</h6><p>这个显而易见，画一个图就可以知道了</p>
<h6 id="B-深度为k的二叉树总结点数至多为2-k-1个，至少有k个结点"><a href="#B-深度为k的二叉树总结点数至多为2-k-1个，至少有k个结点" class="headerlink" title="B.深度为k的二叉树总结点数至多为2^k^-1个，至少有k个结点"></a>B.深度为k的二叉树总结点数至多为2^k^-1个，至少有k个结点</h6><p>这个也不难知道，只需要将每一层的2^i-1^都累加就行</p>
<h6 id="C-叶子结点的数量是度为2的结点的数量加1"><a href="#C-叶子结点的数量是度为2的结点的数量加1" class="headerlink" title="C.叶子结点的数量是度为2的结点的数量加1"></a>C.叶子结点的数量是度为2的结点的数量加1</h6><p>证明：从下往上看，每一个结点都和其前驱结点有一条边相连，但是根结点无前驱结点故无这条边，所有总的结点数等于总边数减一，从上往下看，度为2的结点<em>2+度为1的结点</em>1+叶子结点*0也等于总边数，联立这两个方程组就可以推出这个结论了</p>
<h4 id="2-满二叉树和完全二叉树"><a href="#2-满二叉树和完全二叉树" class="headerlink" title="2.满二叉树和完全二叉树"></a>2.满二叉树和完全二叉树</h4><h6 id="A-满二叉树"><a href="#A-满二叉树" class="headerlink" title="A.满二叉树"></a>A.满二叉树</h6><p>顾名思义就是这棵二叉树每一层都达到了最大的结点数<br>深度为k，结点数必定达到了2^k^-1个，每一层都是满的<br>叶子结点必定在最下面一层<br><img src="https://img-blog.csdnimg.cn/20200213101831165.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h6 id="B-完全二叉树"><a href="#B-完全二叉树" class="headerlink" title="B.完全二叉树"></a>B.完全二叉树</h6><p>深度为k有n个结点的二叉树，当且仅当每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应的时候，称这棵二叉树为完全二叉树<img src="https://img-blog.csdnimg.cn/20200213102716265.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在这里第一棵树为满二叉树，第二树为完全二叉树，完全二叉树中的每一个结点的编号都与这个满二叉树像对应<br><img src="https://img-blog.csdnimg.cn/2020021310292786.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在这里的话，第二棵树就不是完全二叉树，因为在这棵树L 12上面对应着是满二叉树的M 13，没有做到一一对应</p>
<p>其实我觉得吧，判断一棵树是否为完全二叉树，只要看最下面一层上面的其它层是不是每一层都满了，并且最下面这一层每一个结点必须从左往右一次填入，但凡有一个填入不正确，则都不是完全二叉树</p>
<p>完全二叉树的叶子结点只可能分布在最后两层，且对于任何的一个结点，右子树的最大层次为i，那么左子树的层次只可能为i或者i+1、</p>
<h4 id="2-完全二叉树的性质"><a href="#2-完全二叉树的性质" class="headerlink" title="2.完全二叉树的性质"></a>2.完全二叉树的性质</h4><h6 id="A-具有n个结点的完全二叉树的深度为-log2n-1"><a href="#A-具有n个结点的完全二叉树的深度为-log2n-1" class="headerlink" title="A.具有n个结点的完全二叉树的深度为[log2n]+1"></a>A.具有n个结点的完全二叉树的深度为[log<del>2</del>n]+1</h6><p>对log<del>2</del>n进行向下整数的取余，在编程中，如果你定义的就是整形，它会自动取余取整数的</p>
<h6 id="B-一个不为根结点的完全二叉树的结点编号如果是i的话，那么这个结点的双亲结点编号为i-2-这个结点的后继结点的编号为2i和2i-1"><a href="#B-一个不为根结点的完全二叉树的结点编号如果是i的话，那么这个结点的双亲结点编号为i-2-这个结点的后继结点的编号为2i和2i-1" class="headerlink" title="B.一个不为根结点的完全二叉树的结点编号如果是i的话，那么这个结点的双亲结点编号为i/2,这个结点的后继结点的编号为2i和2i+1"></a>B.一个不为根结点的完全二叉树的结点编号如果是i的话，那么这个结点的双亲结点编号为i/2,这个结点的后继结点的编号为2i和2i+1</h6><p>使用这个性质，我们能很快的看出在完全二叉树中的结点的后继和前驱<br><img src="https://img-blog.csdnimg.cn/20200215100052852.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="3-二叉树的顺序存储方式"><a href="#3-二叉树的顺序存储方式" class="headerlink" title="3.二叉树的顺序存储方式"></a>3.二叉树的顺序存储方式</h4><p>按照满二叉树的结点编号，分别对应存储在一个一维数组的相应数组下标的位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> Telemtype sqbitree[maxsize];</span><br><span class="line">sqbitree BT;</span><br></pre></td></tr></table></figure>
<p>一维数组表示：<br>|  11|22  |55|66|77|77|88|99|100|<br>|–|–|–|–|–|–|–|–|–|<br>| 1 | 2 |3|4|5|6|7|8|9||<br><img src="https://img-blog.csdnimg.cn/20200215101154687.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果一些结点为空，那些数组对应的结点编号的数组下标的元素设置为空或者为0</p>
<p>一维数组表示：<br>|  11|22  |55|66|77|0|88|0|100|<br>|–|–|–|–|–|–|–|–|–|<br>| 1 | 2 |3|4|5|6|7|8|9||<br><img src="https://img-blog.csdnimg.cn/20200215101443750.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>例题展示：<br>二叉树的结点采用如图顺序存储的方式，已知该数组的表示，请你画出这个二叉树<br>| a|e|b|f||d|c|g||||h|<br>|–|–|–|–|–|–|–|–|–|–|–|–|–|<br>| 1 | 2 |3|4|5|6|7|8|9|10|11|12|<br>按照满二叉树的编号表示，我们画出满二叉树来，把对应空的位置删除即可<br><img src="https://img-blog.csdnimg.cn/20200215102135940.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后二叉树如图所示：<br><img src="https://img-blog.csdnimg.cn/2020021510214681.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>二叉树顺序存储的缺点：<br>对于一些右单只二叉树来讲，深度为k需要2^k^-1个存储空间，但实际存储的数据只有k个元素，极大的浪费了数组的存储空间，但是对于满二叉树和完全二叉树来讲，顺序存储不失一种很好的存储方式</p>
<h4 id="3-二叉树的链式存储方式"><a href="#3-二叉树的链式存储方式" class="headerlink" title="3.二叉树的链式存储方式"></a>3.二叉树的链式存储方式</h4><p>对于一些单二叉树，我们可以采用链式存储结构，二叉链表或者三叉链表来存储这个二叉树</p>
<h6 id="A-二叉链表"><a href="#A-二叉链表" class="headerlink" title="A.二叉链表"></a>A.二叉链表</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">binode</span>&#123;</span></span><br><span class="line">Telemtype data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binde</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;binode,*bitree;</span><br></pre></td></tr></table></figure>
<p>链表的存储结构展示：<br><img src="https://img-blog.csdnimg.cn/20200215111258237.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> ==在n个结点的二叉链表中，其中存在n+1个空的指针域==<br> 证明：因为在n个结点的二叉链表中，我们可以知道有2n个指针域，除去了根结点之外，每一个结点都有一个双亲结点，所用总共占用了n-1个指针域，2n-(n-1)</p>
<h6 id="B-三叉链表"><a href="#B-三叉链表" class="headerlink" title="B.三叉链表"></a>B.三叉链表</h6><p> 采用二叉链表不方便看到双亲的信息，我们还可以怎填一个指针域来看双亲的信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tribinode</span>&#123;</span></span><br><span class="line">Telemtype data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tribinde</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>,*<span class="title">parent</span>;</span></span><br><span class="line">&#125;tribinode,*tribitree;</span><br></pre></td></tr></table></figure>
<p>三叉链表的展示：<br><img src="https://img-blog.csdnimg.cn/20200215112333195.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4-二叉树的遍历"><a href="#4-二叉树的遍历" class="headerlink" title="4.二叉树的遍历"></a>4.二叉树的遍历</h2><p>顺着一个结点开始按照某种路径寻访二叉树中的每一个结点，使得这个二叉树的每一个结点都被访问，且只访问一次，访问后能做很多的操作<br>遍历能够使二叉树得到一个线性的数据排列<br>得到这个线性排列后，我们后序的插入删除排序等操作就都可以实现<br><img src="https://img-blog.csdnimg.cn/2020021511304628.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-三种遍历方式"><a href="#1-三种遍历方式" class="headerlink" title="1.三种遍历方式"></a>1.三种遍历方式</h3><p>找到这个二叉树的定义，我们可以把遍历分为六种，左子树根右子树，根左子树右子树，左子树右子树根，右子树根左子树，根右子树左子树，右子树左子树根，我们探讨前三种</p>
<p><img src="https://img-blog.csdnimg.cn/20200215113558669.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h6 id="A-先序遍历（根左子树右子树）"><a href="#A-先序遍历（根左子树右子树）" class="headerlink" title="A.先序遍历（根左子树右子树）"></a>A.先序遍历（根左子树右子树）</h6><p>若二叉树为空，则空操作<br>访问根结点<br>先序遍历左子树<br>先序遍历右子树<br>则先序遍历的线性序列为：ABELDHMIJ</p>
<h6 id="B-中序遍历（左子树根右子树）"><a href="#B-中序遍历（左子树根右子树）" class="headerlink" title="B.中序遍历（左子树根右子树）"></a>B.中序遍历（左子树根右子树）</h6><p>若二叉树为空，则空操作<br>中序遍历左子树<br>访问根结点<br>中序遍历右子树<br>则中序遍历的线性序列为：ELBAMHIDJ</p>
<h6 id="C-后序遍历（左子树右子树根）"><a href="#C-后序遍历（左子树右子树根）" class="headerlink" title="C.后序遍历（左子树右子树根）"></a>C.后序遍历（左子树右子树根）</h6><p>若二叉树为空，则空操作<br>后序遍历左子树<br>后序遍历右子树<br>访问根结点<br>则中序遍历的线性序列为：LEBMIHJDA</p>
<p> 例题1练习：<br> <img src="https://img-blog.csdnimg.cn/20200215114318964.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 先序遍历：ABDGCEHF<br> 中序遍历：DGBAEHCF<br> 后序遍历：GDBHEFCA<br> OK 就是这样啦</p>
<p> 例题2练习：<br> <img src="https://img-blog.csdnimg.cn/20200215114924125.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  先序遍历：—+A<em>B—CD/EF（前缀表达 波兰式）<br> 中序遍历：A+B</em>C—D—E/F（中缀表达）<br> 后序遍历：ABCD—*+EF/— （后缀表达 逆波兰式）</p>
<h3 id="2-由两种遍历来求二叉树"><a href="#2-由两种遍历来求二叉树" class="headerlink" title="2.由两种遍历来求二叉树"></a>2.由两种遍历来求二叉树</h3><p>遍历序列总共有三种<br>我们已知前序和中序序列能够求出二叉树<br>我们已知后序和中序序列能够求出二叉树<br>但是已知前序和后序序列不能求出二叉树</p>
<p>例题一：<br>已知二叉树的前序和中序序列，请求出这棵二叉树<br>前序序列：ABCDEFGHIJ<br>中序序列：CDBFEAIHGJ</p>
<p><strong><del>~ 一般做这种题的大概思路就是通过两种序列不断的判断根，左子树和右子树，判断完毕接着判断左子树的这三个，一直到左右子树为一个单节点为止 ~</del></strong><br>这道题通过前序序列能看出根为A，通过中序序列能看出左子树为CDBFE，右子树为IHGJ，接着判断左子树，通过前序序列能看出根为B，通过中序序列能看出左子树为CD，右子树为FE，接着判断左子树，通过前序序列能看出根为C，通过中序序列能看出左子树为空，右子树为D，依次这样进行即可<br><img src="https://img-blog.csdnimg.cn/20200215121337948.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>道理都是这样，但是容易做错呀，刚刚就又错了<br>==要记得通过前序序列判断根，通过中序序列判断左右子树==</p>
<p>例题二：<br>已知二叉树的后序和中序序列，请求出这棵二叉树<br>后序序列：DECBHGFA<br>中序序列：BDCEAFHG</p>
<p>思路也都一样，在这里只不过是把判断根的条件换成了后序序列，通过后序序列判断根，通过中序序列判断左右子树<br><img src="https://img-blog.csdnimg.cn/20200215122247216.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图就行啦</p>
<h3 id="3-二叉树的递归遍历算法"><a href="#3-二叉树的递归遍历算法" class="headerlink" title="3.二叉树的递归遍历算法"></a>3.二叉树的递归遍历算法</h3><p><strong>我们可以采用递归的定义来表示二叉树的先序遍历</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> status;<span class="comment">//status是为了表示一般性，实际使用时要把写status的地方换成对应的数据类型（如int,float,char等）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1<span class="comment">//便于理解，将-1定义为失败，1定义为成功</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="function">status <span class="title">preordertravels</span><span class="params">(bitree T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;data==<span class="literal">NULL</span>)<span class="keyword">return</span> OK;<span class="comment">//如果为空节点的话就返回到上一层</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">visit(T-&gt;data);<span class="comment">//先访问根结点</span></span><br><span class="line">preordertravels(T-&gt;lchild);<span class="comment">//访问左孩子</span></span><br><span class="line">preordertravels(T-&gt;rchild);<span class="comment">//访问右孩子</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这种先序遍历的递归实现，理解起来有一定难度，如果这棵树不为空，就先访问根结点，按照相同的方法访问左孩子，进入到左孩子的判断，左孩子不为空，访问左孩子的根结点，再按照同样的方法访问左孩子的左孩子，一直进行下去，直到左右孩子均为空的时候逐级返回，一直到二叉树中每一个结点都访问到了根结点，左孩子，右孩子为止，<del>还不理解的小朋友可以画图理解一下递归</del><br><strong>二叉树的中序遍历</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> status;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="function">status <span class="title">inordertravels</span><span class="params">(bitree T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;data==<span class="literal">NULL</span>)<span class="keyword">return</span> OK;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">preordertravels(T-&gt;lchild);<span class="comment">//先访问左孩子</span></span><br><span class="line">visit(T-&gt;data);<span class="comment">//访问根结点</span></span><br><span class="line">preordertravels(T-&gt;rchild);<span class="comment">//访问右孩子</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二叉树的后序遍历</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> status;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="function">status <span class="title">postordertravels</span><span class="params">(bitree T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;data==<span class="literal">NULL</span>)<span class="keyword">return</span> OK;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">preordertravels(T-&gt;lchild);<span class="comment">//先访问左孩子</span></span><br><span class="line">preordertravels(T-&gt;rchild);<span class="comment">//访问右孩子</span></span><br><span class="line">visit(T-&gt;data);<span class="comment">//访问根结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比这三种算法，如果去掉访问语句，那么这三种算法是完全一样的，访问的路径也都一样，每一个算法只是在不同的时间对这个结点进行访问<br><img src="https://img-blog.csdnimg.cn/20200217093558855.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>每一个结点都访问到了三次，如左子树结点，就有顺序为1 3 5的访问，而先序遍历是在第1次经过的时候就访问了，顺序为1，而中序遍历是在第2次经过的时候就访问了，顺序为3，而先序遍历是在第3次经过的时候就访问了，顺序为5<br><strong>第一次访问 先序遍历<br>第二次访问 中序遍历<br>第三次访问 后序遍历</strong><br>这时候你要问了，好像左左，左右，右左，右右只经过一次啊，其实不然，他们下面还有空结点，他们也都像根，左孩子，右孩子一样，都经过了三次</p>
<p>那么我们再来看一下这种递归算法的时间复杂度和空间复杂度吧<br>时间复杂度：访问路径就是按照顺序把二叉树都访问一遍，为O(n)<br>空间复杂度：按照最坏的情况来看，这棵二叉树为一棵单只树，每一次递归调用，系统都要存储调用的这个结点，系统用一个栈来实现，那么为单只树的话，系统就要开辟出栈的n个空间来每一个结点，故这种空间复杂度也是为O(n)</p>
<h3 id="4-二叉树的非递归遍历算法"><a href="#4-二叉树的非递归遍历算法" class="headerlink" title="4.二叉树的非递归遍历算法"></a>4.二叉树的非递归遍历算法</h3><p>我们先讨论一下中序遍历<br>中序遍历是先先访问左子树，然后访问根结点，最后访问右子树<br>遇到一个根结点，先把这个根结点存储下来，访问它的左子树，不断的进行知道左子树为空，输出这个左子树为空的结点，访问它的右子树，不断的回溯，先访问的后输出，对比这个，我们很容易想到了用栈来存储这个根结点，先让根结点入栈，访问左孩子，返回的时候，根结点出栈，访问右孩子</p>
<p><strong>基本思想：</strong><br>1.建立一个栈<br>2.根结点入栈，访问左子树<br>3.根结点出栈，输出根结点，访问遍历右子树<br><a href="https://blog.csdn.net/qq_20366761/article/details/70053813">C++栈的用法及栈的实现</a>用C++栈再复习一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> status;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="function">status <span class="title">inordertravels</span><span class="params">(bitree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;status&gt;S;</span><br><span class="line">    bitree p,temp;</span><br><span class="line">    p=T;</span><br><span class="line">    <span class="keyword">while</span>(p||!empty(S))&#123;<span class="comment">//满足一个都会执行，满足p执行if,满足!empty(S)，执行else</span></span><br><span class="line">    <span class="keyword">if</span>(p)&#123;<span class="comment">//p!=NULL</span></span><br><span class="line">        s.push(p);</span><br><span class="line">        p=p-&gt;lchild;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        temp=S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;temp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        p=temp-&gt;lchild;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-二叉树的层次遍历算法"><a href="#5-二叉树的层次遍历算法" class="headerlink" title="5.二叉树的层次遍历算法"></a>5.二叉树的层次遍历算法</h3><p>层次遍历就是讲二叉树一层一层从左向右的进行遍历<br><img src="https://img-blog.csdnimg.cn/20200217103130323.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么这个层次遍历就是：ABFCGDEH<br>因为要一层一层的进行遍历，先进入一个结点，输出这个结点，进入这个结点的左孩子右孩子，先进入的先输出，我们不难想到用队列来实现这种层次遍历<br><a href="https://blog.csdn.net/qq_27484763/article/details/79866109">C++队列传送门</a>可以先看看复习一下，用C++的话就不需要自己写队列了</p>
<p><strong>基本思路</strong><br>1.建立一个队列<br>while(队列不为空){<br>2.取出队列中的一个结点并输出<br>2.将该结点的左右孩子入队}</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelorder</span><span class="params">(bitree T)</span></span>&#123;</span><br><span class="line">    bitree p;<span class="comment">//建立一个暂存结点</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;<span class="comment">//建立队列</span></span><br><span class="line">    q.push(T);<span class="comment">//头结点放入</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;<span class="comment">//队列不为空一直执行</span></span><br><span class="line">        p=q.front();<span class="comment">//取队列的第一个元素</span></span><br><span class="line">        q.pop();<span class="comment">//删除第一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(！p-&gt;lchild)<span class="comment">//左孩子不为空入队列</span></span><br><span class="line">            q.push(p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(！p-&gt;rchild)<span class="comment">//右孩子不为空入队列</span></span><br><span class="line">            q.push(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-根据二叉树的前序遍历序列建立二叉树"><a href="#6-根据二叉树的前序遍历序列建立二叉树" class="headerlink" title="6.根据二叉树的前序遍历序列建立二叉树"></a>6.根据二叉树的前序遍历序列建立二叉树</h3><p>现在我们知道一个前序序列ABCDEFG<br>单靠这个序列我们不可能知道这个二叉树长什么样子的<br>因为有很多种可能<br><img src="https://img-blog.csdnimg.cn/20200217110922192.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那我们把一些空的地方补充上去<br>补充成空的结点用#表示<br><img src="https://img-blog.csdnimg.cn/20200217111322908.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么这样序列就变得唯一了<br>ABC##DE#G##F### </p>
<p><strong>基本思路</strong><br>1.读入一个字符<br>2.不为#的话建立一个结点存储这个字符<br>3.递归执行建立这个结点的左孩子和右孩子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">status <span class="title">creatbitree</span><span class="params">(bitree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;<span class="comment">//输入一个字符</span></span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//为#的话这个是个空节点</span></span><br><span class="line">     T=<span class="literal">NULL</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    T=(binode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(binode));</span><br><span class="line">    T-&gt;data=ch;<span class="comment">//不为#的话，那么存储这个结点值</span></span><br><span class="line">    creatbitree(T-&gt;lchild);<span class="comment">//建立左子树</span></span><br><span class="line">    creatbitree(T-&gt;rchild);<span class="comment">//建立右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归真的很神奇，因为前序序列就是按照根左右的顺序来排列的，输入前序序列，不断的建立左子树，建立到空节点为止，将其赋值为NULL ，通过return OK返回到上一步建立右子树，再次这样一直执行….<del>看一遍不懂的话再看一遍视频里面那个老师的演示，这个很重要的，递归递归！！！！</del> <a href="https://www.bilibili.com/video/av82837069?p=92">传送门</a>传送坐标10:30开始</p>
<h3 id="7-二叉树遍历算法运用"><a href="#7-二叉树遍历算法运用" class="headerlink" title="7.二叉树遍历算法运用"></a>7.二叉树遍历算法运用</h3><h6 id="1-复制二叉树"><a href="#1-复制二叉树" class="headerlink" title="1.复制二叉树"></a>1.复制二叉树</h6><p><strong>基本思路：</strong><br>依然是递归<br>1.如果结点空则新结点也为空，并且返回上一级<br>2.申请新空间，复制结点<br>3.递归调用复制左子树和右子树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copybitree</span><span class="params">(bitree T,bitree &amp;newT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        newT-&gt;data=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    newT=(binode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(binode));</span><br><span class="line">    <span class="comment">//一定要记得，普通的传递一下数不需要动态申请内存</span></span><br><span class="line">    <span class="comment">//但是要用到data等里面的数据的时候就要动态申请内存</span></span><br><span class="line">    newT-&gt;data=T-&gt;data;</span><br><span class="line">    copybitree(T-&gt;lchild,newT-&gt;lchild);</span><br><span class="line">    copybitree(T-&gt;rchild,newT-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归万岁！！！！</p>
<h6 id="2-计算二叉树的深度"><a href="#2-计算二叉树的深度" class="headerlink" title="2.计算二叉树的深度"></a>2.计算二叉树的深度</h6><p><strong>基本思路</strong><br>依然是递归<br>若是空树深度为0<br>1.计算左子树的深度<br>2.计算右子树的深度<br>3.比较左右子树的深度，二叉树的深度就为最大值加一</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitreedepth</span><span class="params">(bitree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    m=bitreedepth(T-&gt;lchild);</span><br><span class="line">    n=bitreedepth(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么说呢，不断的递归下去，一直到data=NULL为止，return返回上一级，不断的返回，有不断的递归下去，知道把整棵二叉树都遍历完全<br>递归万岁！！！！</p>
<h6 id="3-计算二叉树的结点总个数"><a href="#3-计算二叉树的结点总个数" class="headerlink" title="3.计算二叉树的结点总个数"></a>3.计算二叉树的结点总个数</h6><p><strong>基本思路</strong><br>如果是空树的话，返回0<br>1.计算结点的左子树的结点个数<br>2.计算结点的右子树的结点个数<br>3.将结点的左右子树的个数相加再加根的个数即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitrenodecount</span><span class="params">(bitree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data=<span class="literal">NULL</span>)<span class="comment">//如果是空树就返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    m=bitrenodecount(T-&gt;lchild);<span class="comment">//计算左子树的结点个数</span></span><br><span class="line">    n=bitrenodecount(T-&gt;rchild);<span class="comment">//计算右子树的结点个数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> m+n+<span class="number">1</span>;<span class="comment">//相加再加上根的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-计算二叉树的叶子结点总个数"><a href="#4-计算二叉树的叶子结点总个数" class="headerlink" title="4.计算二叉树的叶子结点总个数"></a>4.计算二叉树的叶子结点总个数</h6><p>如果是空树的话，返回0<br>如果是叶子结点的话，返回1<br>1.计算结点的左子树的叶子结点个数<br>2.计算结点的右子树的叶子结点个数<br>3.将结点的左右子树的叶子个数相加即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitreleadcount</span><span class="params">(bitree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data=<span class="literal">NULL</span>)<span class="comment">//如果是空树就返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild=<span class="literal">NULL</span>&amp;&amp;T-&gt;rchild=<span class="literal">NULL</span>)</span><br><span class="line">    m=bitreleadcount(T-&gt;lchild);<span class="comment">//计算左子树的结点个数</span></span><br><span class="line">    n=bitreleadcount(T-&gt;rchild);<span class="comment">//计算右子树的结点个数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> m+n;<span class="comment">//相加即为总叶子结点个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-线索二叉树"><a href="#5-线索二叉树" class="headerlink" title="5.线索二叉树"></a>5.线索二叉树</h2><p>当使用二叉链表来存储一棵二叉树的时候，可以很方便的找到某个结点的左右孩子，但是我们很难找到按照结点对应的前序中序后序序列排序字母的前驱和后继，<br>为了解决这种情况<br>1.可以再遍历一次寻找其前驱和后继–浪费时间<br>2.再增加前驱和后继指针–浪费空间<br>3.我们前面知道一棵二叉树有2n个指针域，其中空存着n+1个指针域，我们不妨利用<br>这些空存的指针域来进行操作</p>
<p>那么我们规定：如果一个结点的左孩子为空，那么我们把他的左孩子指针域指向对应的排序序列的前驱字母，如果一个结点的右孩子为空，那我们把他的右孩子指针域指向对应排序序列的后继字母，左前右后</p>
<p>这种改变的指针域我们称之为线索<br>这种改变的二叉树我们称之为线索二叉树<br>将二叉树改变为线索二叉树的过程我们称之为线索化<br><img src="https://img-blog.csdnimg.cn/20200217154640605.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图所示：按照序列C后面是B，那么C的右指针域指向B，E后面是G，E的右指针域指向G，依次类推，按照前序中序后序序列的字母排列顺序不同来线索化</p>
<p>那么接下来问题又来了，我们让一个结点无论是否为空左右指针域都不为空，我们怎么判断这些指针是普通指针呢还是线索指针呢？</p>
<p>我们可以牺牲一点存储空间设置两个标志域，ltag和rtag<br>当ltag和rtag为0的时候 这时候是分别指向左孩子和右孩子<br>当ltag和rtag为1的时候，这时候它们是线索指针域<br>那么现在结点的结构就为：<br>|lchild  | ltag|data|rtag|rchild|<br>|–|–|–|–|–|</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bithrnode</span>&#123;</span></span><br><span class="line">    elemtype data;</span><br><span class="line">    <span class="keyword">int</span> ltaf,rtag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bithrtree</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;bithrnode,*bithrtree;</span><br></pre></td></tr></table></figure>
<p>先序遍历二叉树线索化：<br><img src="https://img-blog.csdnimg.cn/20200217161733892.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>中序遍历二叉树线索化：<br><img src="https://img-blog.csdnimg.cn/2020021716190216.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>例题1：<br><img src="https://img-blog.csdnimg.cn/20200217161948741.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这种题的一般思路就是先把二叉树按照题目给定的遍历序列把字母排序序列写出，再进行线索化即可</p>
<p>那么从这里我们可以看出其实序列的第一个元素H前面没有元素，所以它的lchild指针还是为空的，G元素后面没有元素，所以它的rchild指针域也还是空的，为了规范统一，我们可以再引入一个头指针</p>
<p>头指针里面的data域为空<br>头指针的ltag=0 指向根结点<br>头指针的rtag=1 指向该排序序列的最后一个结点元素<br>让空余的那两个指针域指向头结点<br>这样就都完成了其中的规范性<br><img src="https://img-blog.csdnimg.cn/20200217162656963.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>OK！今天的学习完成啦！！！！奥利给！！！！</p>
<h2 id="5-树和森林"><a href="#5-树和森林" class="headerlink" title="5.树和森林"></a>5.树和森林</h2><p>前面我们学习了二叉树的存储方式，有用数组存储的顺序存储方式（按照满二叉树的编号来存储对应数组的地址来存储数据），有用链表存储的链式存储方式，那今天我们来学习一下更为普遍的树的存储方式</p>
<h4 id="1-普通树的存储表示"><a href="#1-普通树的存储表示" class="headerlink" title="1.普通树的存储表示"></a>1.普通树的存储表示</h4><h6 id="A-双亲表示法"><a href="#A-双亲表示法" class="headerlink" title="A.双亲表示法"></a>A.双亲表示法</h6><p>定义结构数组存放树的结点，每个结点包含两个域，一个是本身的数值域，另外一个是该结点双亲在数组中存放的位置下标<br>|Array | data  |parent|<br>|–|–|–|<br>|0|R|-1|<br>|  1|  A|0|<br>|2|B|0|<br>|3|C|0|<br>|4|D|1|<br>|5|E|1|<br>|6|F|3|<br>|7|G|6|<br>|8|H|6|<br>|9|K|6|<br>那么按照这样数组的存储方式，我们就可以很清晰的画出这棵树了<br><img src="https://img-blog.csdnimg.cn/20200218103440124.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>像这种存储方式的特点就是：找到双亲很容易，但是要找到孩子结点的时候，需要遍历整个数组来看每个结点的双亲结点是否为这个结点的数组下标</p>
<p>C语言类型描述：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTnode</span>&#123;</span><span class="comment">//单个结点的数值域和双亲域</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125;PTnode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxtreesize 100</span></span><br><span class="line"><span class="keyword">typedef</span> strcut&#123;</span><br><span class="line">    PTnode nodes[maxtreesize];</span><br><span class="line">    <span class="keyword">int</span> r,n;<span class="comment">//分别记录根结点的位置和结点的总个数</span></span><br><span class="line">&#125;PTtree,*PTptr;</span><br></pre></td></tr></table></figure>
<h6 id="B-孩子表示法"><a href="#B-孩子表示法" class="headerlink" title="B.孩子表示法"></a>B.孩子表示法</h6><p>为了解决上面那个寻找孩子困难的问题，我们不妨采用把结点的所有孩子按照从左往右的顺序连成单链表（叶子结点的单链表为空），这些链表的头指针又和每一个结点的数据元素共同组成顺序表，这样一来，寻找孩子结点就变得很容易了，只需要从顺序表中每一个结点后面相连的单链表，孩子结点就都知道了<br><img src="https://img-blog.csdnimg.cn/20200218105719386.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>按照这样的存储方式，r(根结点)=4，n=10，这棵树我们也可以一目了然的知道长什么样子了<br><img src="https://img-blog.csdnimg.cn/20200218110252613.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>C语言类型描述：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxtreesize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTnode</span>&#123;</span><span class="comment">//定义单链表孩子格式</span></span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*childptr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//定义每一个结点的数值域和第一个孩子的位置</span></span><br><span class="line">    elemtype data;</span><br><span class="line">    childptr firstchild;</span><br><span class="line">&#125;CTbox;</span><br><span class="line"><span class="keyword">typedef</span> strcut&#123;<span class="comment">//按照每一个结点的定义方式组成顺序表</span></span><br><span class="line">    CTbox nodes[maxtreesize];</span><br><span class="line">    <span class="keyword">int</span> r,n;<span class="comment">//分别记录根结点的位置和结点的总个数</span></span><br><span class="line">&#125;CTtree,*CTptr;</span><br></pre></td></tr></table></figure>
<p>按照这样定义以后<br>数组第一个结点的数值域——&gt;第一个孩子的数组下标——&gt;下一个孩子数组下标….<br>数组第二个结点的数值域——&gt;第一个孩子的数组下标——&gt;下一个孩子数组下标….<br>数组第三个结点的数值域——&gt;第一个孩子的数组下标——&gt;下一个孩子数组下标….<br>数组第四个结点的数值域——&gt;第一个孩子的数组下标——&gt;下一个孩子数组下标….<br>……..</p>
<p>总共就构成了一个顺序表的形式</p>
<p>但是这种孩子表示法又产生了一个缺点，就是寻找双亲很困难，要找结点的双亲要遍历顺序表找到某个结点下面对应的孩子正好是这个结点的话才能找到，那我们可以试试把第一种方法和第二种方法结合起来，在孩子表示法的基础上面，顺序表再增加一个对应双亲结点数组下标的数值域，记录每一个结点的双亲，这样一来，对于任意的一个结点，我们寻找它的孩子和双亲都变得很容易</p>
<h6 id="C-孩子兄弟表示法（二叉链表表示法）"><a href="#C-孩子兄弟表示法（二叉链表表示法）" class="headerlink" title="C.孩子兄弟表示法（二叉链表表示法）"></a>C.孩子兄弟表示法（二叉链表表示法）</h6><p>利用二叉链表作为树的存储结构，里面总共有三个域，第一个是一样的数值域，第二个第三个分别是指向第一个孩子结点和指向下一个兄弟</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">csnode</span>&#123;</span></span><br><span class="line">    elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">csnode</span> *<span class="title">firstchild</span>,*<span class="title">nextbro</span>;</span></span><br><span class="line">&#125;csnode,*cstree;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200218114300615.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么一棵树就可以通过这样存储在二叉链表上面<br><img src="https://img-blog.csdnimg.cn/20200218114315368.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>找孩子结点只需要向左移动一位，向右就全部都是孩子结点<br>找兄弟结点只需要向右移动全部就是兄弟结点了</p>
<h4 id="2-树和二叉树的转换"><a href="#2-树和二叉树的转换" class="headerlink" title="2.树和二叉树的转换"></a>2.树和二叉树的转换</h4><p>我们知道树可以通过二叉链表的形式来存储，而二叉树的链式存储结构和二叉链表也基本类似，那么我们就可以通过二叉链表的形式来进行对数和二叉树的转换，如果成功的转换成功的话，我们就知道可以利用二叉树的算法来对树进行操作</p>
<p>前面我们知道对于任何的一棵树来讲，如果要存储在二叉链表上面，它的左孩子是第一个孩子，右孩子是第一个兄弟结点，那么我们按照这样的规律就来对树进行转换</p>
<h6 id="1-树转换为二叉树"><a href="#1-树转换为二叉树" class="headerlink" title="1.树转换为二叉树"></a>1.树转换为二叉树</h6><p><img src="https://img-blog.csdnimg.cn/20200220085849791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过这样的形式我们就可以对树进行转化，一棵树有且仅有一棵二叉树与之对应<br>那么接下来我们观察树和其对应的二叉树</p>
<p>我们不难看出这样规律：<br>在所有的兄弟结点之间连接一条线<br>每一个结点出来第一个左孩子之外，去除与其他的孩子连线<br>将整颗转换的树旋转45度</p>
<p><strong>兄弟相连留长子</strong><img src="https://img-blog.csdnimg.cn/20200220090701702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h6 id="2-二叉树转化为树"><a href="#2-二叉树转化为树" class="headerlink" title="2.二叉树转化为树"></a>2.二叉树转化为树</h6><p>那么这样的相逆的转化，我们通过上面操作的逆运算即可完成<br>首先找到一个结点的左孩子，将左孩子的右孩子，左孩子的右孩子的右孩子…与这个结点都连一条线，然后把左孩子与左孩子的右孩子…之间的连线全部都断开<br><img src="https://img-blog.csdnimg.cn/20200220091431381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>左孩右右连双亲，去掉原来右孩线</strong></p>
<h4 id="3-森林和二叉树的转换"><a href="#3-森林和二叉树的转换" class="headerlink" title="3.森林和二叉树的转换"></a>3.森林和二叉树的转换</h4><h6 id="1-森林转换为二叉树"><a href="#1-森林转换为二叉树" class="headerlink" title="1.森林转换为二叉树"></a>1.森林转换为二叉树</h6><p><img src="https://img-blog.csdnimg.cn/20200220094107856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先把每一棵树都转化为二叉树<br>再把这些二叉树的根结点全部都相连<br>以第一棵二叉树的根结点为轴顺时针旋转45度即可</p>
<p><strong>树变二叉根相连</strong></p>
<h6 id="2-二叉树转换为森林"><a href="#2-二叉树转换为森林" class="headerlink" title="2.二叉树转换为森林"></a>2.二叉树转换为森林</h6><p>相逆即可<br>去掉全部的根结点相连的右孩子，使转换为孤立的二叉树<br>再对每一棵二叉树进行还原即可</p>
<p><strong>去掉全部右孩线<br>孤立二叉再还原</strong></p>
<h4 id="4-树的遍历"><a href="#4-树的遍历" class="headerlink" title="4.树的遍历"></a>4.树的遍历</h4><p>树的遍历右三种方法<br>1.先根遍历：<br>树不空，先访问根结点，依次遍历各课子树<br>2.后根遍历<br>树不空，先依次遍历各棵子树，再访问根结点<br>3.层次遍历<br>树不空，自上而下从左往右的访问每一棵树的结点<br><img src="https://img-blog.csdnimg.cn/20200220100101950.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先根遍历：ABCDE<br>后根遍历：BDCEA<br>层次遍历：ABCED</p>
<p>这里又有同学要问了，二叉树不是有四种遍历方式吗，怎么树的遍历少了一种中根遍历，这是因为树可能会有多个孩子，中根遍历是把树结点的位置放到中间，但是又个孩子的情况下，你不知道该放到哪个中间，所以那就彻底把这种遍历去掉比较简单</p>
<h4 id="5-森林的遍历"><a href="#5-森林的遍历" class="headerlink" title="5.森林的遍历"></a>5.森林的遍历</h4><p>我们可以将森林看做三部分<br>1.森林中的第一棵树的结点<br>2.森林中的第一棵树的子树<br>3.森林中其他的树</p>
<p>按照这些排序方式，我们又可以把森林的遍历分作俩种情况<br>1.先序遍历：<br>按照从左往右的顺序，先根遍历森林中的每一棵树<br>2.中序遍历：<br>按照从左往右的顺序，后跟遍历森林中的每一棵树<br><img src="https://img-blog.csdnimg.cn/20200220101055651.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2NTMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>按照先序遍历的方式：ABCDEFGHIJ<br>按照中序遍历的方式：BCDAFEHJIG</p>
<h2 id="6-哈夫曼树（最优二叉树）"><a href="#6-哈夫曼树（最优二叉树）" class="headerlink" title="6.哈夫曼树（最优二叉树）"></a>6.哈夫曼树（最优二叉树）</h2><p>哈夫曼是一个在计算机领域方面杰出的领军者<br>对于不同的判断树，会有不同的效率<br>而哈夫曼树就是在所有判断树中效率最高的一棵树<br>又被称之为最优二叉树</p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>sort排序讲解</title>
    <url>/orange-cat-win.github.io/2020/08/12/sort%E6%8E%92%E5%BA%8F%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="1-需要头文件算法库"><a href="#1-需要头文件算法库" class="headerlink" title="1.需要头文件算法库"></a>1.需要头文件算法库</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-常规的使用方法"><a href="#2-常规的使用方法" class="headerlink" title="2.常规的使用方法"></a>2.常规的使用方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    sort(a,a+<span class="number">3</span>);<span class="comment">//对第一个到第三个元素进行排序</span></span><br><span class="line">    <span class="comment">//实际上就是对数组下标为0,1,2的元素排序</span></span><br><span class="line">    <span class="comment">//所以假设给定l1到r1排序</span></span><br><span class="line">    <span class="comment">//sort(a+l1-1,a+r1);</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);<span class="comment">//计算数组的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>结果输出为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>上面的是升序的排列方式，如果要使用降序的排列方式<br>增加一个greater<int>()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    sort(a,a+<span class="number">3</span>,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="3带有cmp函数的使用方法"><a href="#3带有cmp函数的使用方法" class="headerlink" title="3带有cmp函数的使用方法"></a>3带有cmp函数的使用方法</h3><p>对于一些特殊的结构体或者特殊的要求，我们可以自己构造cmp函数来让程序按照cmp函数的要求进行排序，下面是两道例子</p>
<h4 id="A整数排序"><a href="#A整数排序" class="headerlink" title="A整数排序"></a>A整数排序</h4><h5 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h5><p>我们有 N 个正整数，均小于 10000。现在需要将这些正整数按照除以 3的余数从小到大排序，即除以 3 余 0 的数排在除以 3 余 1 的数前面，除以 3 余 1 的数排在除以 3 余 2 的数前面。如果余数相等，则按照正整数的值从小到大排序。</p>
<h5 id="构造的cmp函数"><a href="#构造的cmp函数" class="headerlink" title="构造的cmp函数"></a>构造的cmp函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a%<span class="number">3</span>!=b%<span class="number">3</span>)<span class="keyword">return</span> a%<span class="number">3</span>&lt;b%<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a&lt;b; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;<span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+N,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这里就做到了如果余数不相等，按照余数从小到大的顺序输出，如果余数相等按照原数从小到大的顺序输出</p>
<h4 id="B无条件的结构体排序"><a href="#B无条件的结构体排序" class="headerlink" title="B无条件的结构体排序"></a>B无条件的结构体排序</h4><p>这里小于号就是按照从小到大的顺序来进行排序的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Student x,Student y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.score&lt;y.score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C有条件的结构体排序"><a href="#C有条件的结构体排序" class="headerlink" title="C有条件的结构体排序"></a>C有条件的结构体排序</h4><h5 id="题目要求-1"><a href="#题目要求-1" class="headerlink" title="题目要求"></a>题目要求</h5><p>假设结构体里面成绩是一个四个空间的数组，学生们按照第一个成绩排序，谁成绩好谁就排序在前面，相等的话看第二个，一次类推</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> score[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Student x,Student y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.score[<span class="number">0</span>]!=y.score[<span class="number">0</span>])<span class="keyword">return</span> x.score[<span class="number">0</span>]&gt;y.score[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(x.score[<span class="number">1</span>]!=y.score[<span class="number">1</span>])<span class="keyword">return</span> x.score[<span class="number">1</span>]&gt;y.score[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(x.score[<span class="number">2</span>]!=y.score[<span class="number">2</span>])<span class="keyword">return</span> x.score[<span class="number">2</span>]&gt;y.score[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> x.score[<span class="number">3</span>]&gt;y.score[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话是大于号，就是按照从大到小的顺序来进行排列的,在一个程序当中可以多个排序的方法，按照名字排序或者成绩排序，灵活的使用就可以了</p>
<h4 id="D浮点数排序"><a href="#D浮点数排序" class="headerlink" title="D浮点数排序"></a>D浮点数排序</h4><h5 id="题目要求-2"><a href="#题目要求-2" class="headerlink" title="题目要求"></a>题目要求</h5><p>我们有 NNN 个正浮点数，均小于 10000.0。现在需要将这些浮点数按照离它最近的整数的差从小到大排序，浮点数与距离最近的整数的差越小，这个浮点数的排位越靠前；如果差相等，按照浮点数的值从小到大排序。</p>
<h5 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h5><p>bool类型的函数不要在意返回的具体数值，主要是返回一个判断的逻辑，另外介绍四个函数，头文件要包含cmath<br>1.fabs()函数:<br>（取一个数的绝对值）<br>2.ceii()函数：<br>（对一个数向上取整，但是返回类型是double）<br>3.floor()函数：<br>（对一个数向下取整，但是返回类型是double）<br>4.round()函数<br>（对一个数四舍五入的取整，计算结果也为double）<br>5.(int)(x+0.5)这个也能实现对一个数进行四舍五入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPSILON 1e-6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mode 100000007 </span></span><br><span class="line"><span class="keyword">double</span> num[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> dx=<span class="built_in">fabs</span>(x-(<span class="keyword">int</span>)(x+<span class="number">0.5</span>));<span class="comment">//用double的话就全部都用double就好了 </span></span><br><span class="line">    <span class="keyword">double</span> dy=<span class="built_in">fabs</span>(y-(<span class="keyword">int</span>)(y+<span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(dx-dy)&lt;EPSILON)<span class="keyword">return</span> x&lt;y;</span><br><span class="line">    <span class="keyword">return</span> dx&lt;dy;<span class="comment">//不要在意返回的值，主要是返回判断大小的逻辑 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">    sort(num,num+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==n<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>,num[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.6lf &quot;</span>,num[i]);<span class="comment">//注意行末空格的问题 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>sort函数</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
